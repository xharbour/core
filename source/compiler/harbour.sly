%{
/*
 * $Id: harbour.sly 9925 2013-02-11 19:24:52Z zsaulius $
 */

/*
 * Harbour Project source code:
 * Compiler YACC rules and actions
 *
 * Copyright 1999 Antonio Linares <alinares@fivetech.com>
 * www - http://www.harbour-project.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA (or visit
 * their web site at http://www.gnu.org/).
 *
 */

/* TODO list
 * 1) Change the pcode generated by ::cVar from Self:cVar to QSELF():cVar
 *    The major problem to solve is how to support QSELF() inside a codeblock.
 */

#include "hbcomp.h"

#include "hbexemem.h"

/* Compile using: bison -d -v harbour.y */

/* to pacify some warnings in BCC */
#if ( defined( __BORLANDC__ ) || defined( _MSC_VER ) ) && !defined( __STDC__ )
#  define __STDC__
#endif

#if defined( __POCC__ )
   #pragma warn(push)
   #pragma warn(disable:2154)
#elif defined( _MSC_VER )
   #pragma warning(disable:4702) // unreachable code
#elif defined( __BORLANDC__ )
   #pragma warn -aus
   #pragma warn -ccc
   #pragma warn -rch
#endif

#undef alloca
#define alloca  malloc

#ifdef FORCE_MEM_STD
   #undef  hb_xgrab
   #define hb_xgrab malloc

   #undef  hb_xrealloc
   #define hb_xrealloc realloc

   #undef  hb_xfree
   #define hb_xfree free
#else
   #undef malloc
   #define malloc  hb_xgrab
   #undef realloc
   #define realloc hb_xrealloc
   #undef free
   #define free    hb_xfree
#endif

/* NOTE: these symbols are used internally in bison.simple
 */
#undef YYFREE
#define YYFREE free
#undef YYMALLOC
#define YYMALLOC malloc

extern FILE *yyin;      /* currently yacc parsed file */
extern char *yytext;

#ifdef __cplusplus
typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE yy_create_buffer( FILE *, int ); /* yacc functions to manage multiple files */
extern void yy_switch_to_buffer( YY_BUFFER_STATE ); /* yacc functions to manage multiple files */
extern void yy_delete_buffer( YY_BUFFER_STATE ); /* yacc functions to manage multiple files */
#else
extern void * yy_create_buffer( FILE *, int ); /* yacc functions to manage multiple files */
extern void yy_switch_to_buffer( void * ); /* yacc functions to manage multiple files */
extern void yy_delete_buffer( void * ); /* yacc functions to manage multiple files */
#endif

/* lex & yacc related prototypes */
extern int yyparse( void );    /* main yacc parsing function */
extern void yyerror( char * ); /* parsing error management function */
extern int yylex( void );      /* main lex token function, called by yyparse() */
#ifdef __cplusplus
extern "C" int yywrap( void );
#else
extern int yywrap( void );     /* manages the EOF of current processed file */
#endif

static void hb_compLoopStart( BOOL );
static long hb_compLoopCount( void );
static void hb_compLoopEnd( void );
static void hb_compLoopLoop( void );
static void hb_compLoopExit( void );
static void hb_compLoopHere( void );

static void * hb_compElseIfGen( void * pFirstElseIf, HB_SIZE ulOffset ); /* generates a support structure for elseifs pcode fixups */
static void hb_compElseIfFix( void * pIfElseIfs ); /* implements the ElseIfs pcode fixups */

static void hb_compRTVariableAdd( HB_EXPR_PTR, BOOL );
static void hb_compRTVariableGen( char * );

static void hb_compVariableDim( char *, HB_EXPR_PTR );

#ifdef HARBOUR_YYDEBUG
   #define YYDEBUG        1 /* Parser debug information support */
#endif

typedef struct __ELSEIF
{
   HB_SIZE ulOffset;
   struct __ELSEIF * pNext;
   struct __ELSEIF * pPrevGroup;
} _ELSEIF, * PELSEIF;      /* support structure for else if pcode fixups */

typedef struct _LOOPEXIT
{
   HB_SIZE            ulOffset;
   BOOL               fCanLoop;
   int                iLine;
   USHORT             wSeqCounter;
   USHORT             wWithObjCounter;
   USHORT             wFinallyCounter;
   struct _LOOPEXIT * pLoopList;
   struct _LOOPEXIT * pExitList;
   struct _LOOPEXIT * pNext;
} LOOPEXIT, * PTR_LOOPEXIT;  /* support structure for EXIT and LOOP statements */

typedef struct HB_RTVAR_
{
   HB_EXPR_PTR pVar;
   BOOL bPopValue;
   struct HB_RTVAR_ *pNext;
   struct HB_RTVAR_ *pPrev;
} HB_RTVAR, *HB_RTVAR_PTR; /* support structure for PUBLIC and PRIVATE statements */

USHORT hb_comp_wSeqCounter      = 0;
USHORT hb_comp_wForCounter      = 0;
USHORT hb_comp_wIfCounter       = 0;
USHORT hb_comp_wWhileCounter    = 0;
USHORT hb_comp_wCaseCounter     = 0;
USHORT hb_comp_wWithObjCounter  = 0;
USHORT hb_comp_wFinallyCounter  = 0;

HB_SIZE hb_comp_alLastSwitchPos[ HB_MAX_SWITCHES ];
USHORT hb_comp_wSwitchCounter   = 0;

char * hb_comp_buffer; /* yacc input buffer */

static HB_RTVAR_PTR hb_comp_rtvars   = NULL;
static PTR_LOOPEXIT hb_comp_pLoops   = NULL;
static PELSEIF      hb_comp_pElseIfs = NULL;

static BOOL bTrancuateBaseArray = FALSE;
static HB_EXPR_PTR pGetArgList, pBaseArrayName = NULL, pGetVarArray, pGetFunction;

static BOOL s_bBlockMacro = FALSE, s_bBlockDeclared = FALSE;
static HB_EXPR_PTR pBlockSimple;

static int s_iLastControlLine = 0, s_iControlLevel = 0;

extern char * hb_comp_SLX_LastBlock( BOOL bReset );

extern HB_COMP_IDS hb_compExpr_IDs;

char * hb_comp_szAnnounce = NULL;    /* ANNOUNCEd procedure */

BOOL   hb_comp_bVarParams = FALSE;

typedef struct _LOCALPARAM
{
  char *szName;
  char cType;
  struct _LOCALPARAM *pNext;
} LOCALPARAM, *PLOCALPARAM;

PLOCALPARAM hb_comp_LocalParams = NULL;

typedef struct _BLOCKSLIST
{
  HB_EXPR_PTR pBlock;
  struct _BLOCKSLIST *pOuter;
} BLOCKSLIST, *PBLOCKSLIST;

PBLOCKSLIST hb_comp_BlocksList = NULL;

static void hb_compYYError( char cPrefix, int iError, const char * szError1, const char * szError2 );

static void hb_compDebugStart( void ) { };

%}

%union                     /* special structure used by lex and yacc to share info */
{
   char *      string;     /* to hold a string returned by lex */
   int         iNumber;    /* to hold a temporary integer number */
   HB_LONG     lNumber;    /* to hold a temporary long number */
   HB_EXPR_PTR asExpr;
   void * pVoid;           /* to hold any memory structure we may need */
   struct
   {
      int      iNumber;    /* to hold a number returned by lex */
      char *   szValue;
   } valInteger;
   struct
   {
      HB_LONG  lNumber;    /* to hold a long number returned by lex */
      char *   szValue;
   } valLong;
   struct
   {
      double   dNumber;    /* to hold a double number returned by lex */
                           /* NOTE: Intentionally using "unsigned char" instead of "BYTE" */
      UCHAR    bWidth;     /* to hold the width of the value */
      UCHAR    bDec;       /* to hold the number of decimal points in the value */
      char *   szValue;
   } valDouble;
   struct
   {
      char *   string;
      int      length;
      BOOL     dealloc;
   } valChar;
};

%token FUNCTION PROCEDURE IDENTIFIER RETURN NIL NUM_DOUBLE INASSIGN NUM_INTEGER NUM_LONG
%token LOCAL STATIC GLOBAL EXTERNGLOBAL IIF IF ELSE ELSEIF END ENDIF LITERAL TRUEVALUE FALSEVALUE NULLVALUE
%token ANNOUNCE DYNAMIC EXTERN INIT EXIT AND OR NOT PUBLIC EQ NE1 NE2
%token INC DEC ALIASOP DOCASE CASE OTHERWISE ENDCASE ENDDO MEMVAR
%token WHILE LOOP FOR NEXT TO STEP LE GE FIELD IN PARAMETERS H12AM H12PM
%token PLUSEQ MINUSEQ MULTEQ DIVEQ POWER EXPEQ MODEQ
%token PRIVATE BEGINSEQ BREAK RECOVER RECOVERUSING DO WITH SELF LINE
%token MACROVAR MACROTEXT
%token AS_ARRAY AS_BLOCK AS_CHARACTER AS_CLASS AS_DATE AS_LOGICAL AS_NUMERIC AS_OBJECT AS_ENUM AS_VARIANT DECLARE OPTIONAL DECLARE_CLASS DECLARE_MEMBER
%token AS_ARRAY_ARRAY AS_BLOCK_ARRAY AS_CHARACTER_ARRAY AS_CLASS_ARRAY AS_DATE_ARRAY AS_LOGICAL_ARRAY AS_NUMERIC_ARRAY AS_OBJECT_ARRAY AS_ENUM_ARRAY
%token PROCREQ GET
%token WITHOBJ FOREACH EPSILON
%token ENUM
%token TRY CATCH
%token SWITCH DEFAULT ENDSWITCH
%token CRITICAL CRITICAL_STATIC
%token CBMARKER
%token BITAND BITOR BITXOR BITSHIFTR BITSHIFTL
%token FINALLY
%token HASHOP
%token UTILITY
%token DIVERT OF FLAGS
%token NAMESPACE RUNTIME_NAMESPACE OPTIONAL_NAMESPACE EXTERNAL_NAMESPACE EXTERNAL_NAMESPACE_MEMBER IMPLEMENTS_NAMESPACE
%token DEFINE_NAMESPACE DEFINE_NAMESPACEMEMBER USING_NAMESPACE WITH_NAMESPACE

/*the lowest precedence*/
/*postincrement and postdecrement*/
%left  POST

/*assigment - from right to left*/
%right INASSIGN
%right PLUSEQ MINUSEQ
%right MULTEQ DIVEQ MODEQ
%right EXPEQ

/*logical operators*/
%right OR
%right AND
%right NOT

/* Bitwise */
%right BITOR
%right BITXOR
%right BITAND

/*relational operators*/
%right '=' EQ NE1 NE2
%right '<' '>' LE GE '$' LIKE MATCH

/* Bit shift */
%right BITSHIFTR BITSHIFTL

/*mathematical operators*/
%right  '+' '-'
%right  '*' '/' '%'
%right  POWER
%right  UNARY
/*preincrement and predecrement*/
%right  PRE
/*special operators*/
%right  ALIASOP '&' '@'
%right  '\n' ';' ','
/*the highest precedence*/

%type <string>  IdentName IDENTIFIER MACROVAR MACROTEXT CompTimeStr
%type <valChar> LITERAL
%type <valDouble>  NUM_DOUBLE
%type <valInteger> NUM_INTEGER
%type <valLong>    NUM_LONG
%type <iNumber> FunScope
%type <iNumber> IfBegin VarList ExtVarList
%type <iNumber> FieldList
%type <lNumber> WhileBegin
%type <pVoid>   IfElseIf Cases
%type <asExpr>  Argument ArgList BlockExpList BlockVarList BlockParams SendId
%type <asExpr>  DoName DoProc DoArgument DoArgList
%type <asExpr>  PareExpList1 PareExpList2 PareExpList3 PareExpListN
%type <asExpr>  ExpList ExpList1 ExpList2 ExpList3
%type <asExpr>  NumValue NumAlias
%type <asExpr>  NilValue NilAlias
%type <asExpr>  LiteralValue LiteralAlias
%type <asExpr>  CodeBlock CodeBlock2 CodeBlockAlias
%type <asExpr>  Logical LogicalAlias
%type <asExpr>  SelfValue SelfAlias
%type <asExpr>  Array ArrayAlias
%type <asExpr>  ArrayAt ArrayAtAlias
%type <asExpr>  Date DateAlias
%type <asExpr>  DateTime DateTimeAlias
%type <asExpr>  Variable VarAlias
%type <asExpr>  MacroVar MacroVarAlias
%type <asExpr>  MacroExpr MacroExprAlias
%type <asExpr>  MacroText
%type <asExpr>  AliasId AliasVar AliasExpr
%type <asExpr>  VariableAt VariableAtAlias
%type <asExpr>  FunCall FunCallAlias IIFInline
%type <asExpr>  ObjectData ObjectDataAlias
%type <asExpr>  ObjectMethod ObjectMethodAlias
%type <asExpr>  WithData WithMethod
%type <asExpr>  PareExpList PareExpListAlias
%type <asExpr>  Expression SimpleExpression LValue
%type <asExpr>  EmptyExpression
%type <asExpr>  ExprAssign ExprOperEq ExprPreOp ExprPostOp
%type <asExpr>  ExprEqual ExprMath ExprBool ExprRelation ExprUnary
%type <asExpr>  ExprPlusEq ExprMinusEq ExprMultEq ExprDivEq ExprModEq ExprExpEq
%type <asExpr>  ArrayIndex IndexList
%type <asExpr>  DimIndex DimList
%type <asExpr>  FieldAlias FieldVarAlias
%type <asExpr>  PostOp
%type <asExpr>  Get GetArgList
%type <asExpr>  Constant
%type <iNumber> SwitchCases
%type <asExpr>  Hash HashList
%type <asExpr>  DivertFlags
%type <string>  NamespacePath NamespaceName ImplementsNamespace
%type <iNumber> NamespaceType
%type <pVoid>   UsedPath
%type <pVoid>   ParamList;

%destructor { if( $$.dealloc ) hb_xfree( $$.string ); } LITERAL

%%

Main       : { hb_compLinePush(); } Source       { }
           | /* empty file */
           ;

Source     : Crlf
           | VarDefs
           | FieldsDef
           | MemvarDef
           | Declaration
           | EnumDef
           | Function
           | Statement
           | Line
           | ProcReq
           | Namespace
           | ExtNamespace
           | NamespaceDefinition
           | NamespaceUsing
           | WithNamespace
           | Source Crlf
           | Source VarDefs
           | Source FieldsDef
           | Source MemvarDef
           | Source Declaration
           | Source EnumDef
           | Source Function
           | Source Statement
           | Source Line
           | Source ProcReq
           | Source Namespace
           | Source ExtNamespace
           | Source NamespaceDefinition
           | Source NamespaceUsing
           | Source WithNamespace
           ;

Line       : LINE NUM_INTEGER LITERAL Crlf { ( void ) $3; hb_comp_iLine =  $<iNumber>2; }
           | LINE NUM_INTEGER LITERAL '@' LITERAL Crlf { ( void ) $3; ( void ) $5; hb_comp_iLine =  $<iNumber>2; }  /* Xbase++ style */
           ;

ProcReq    : PROCREQ CompTimeStr ')' Crlf {}
           ;

CompTimeStr : LITERAL {
               if( $1.dealloc )
               {
                  $1.string = hb_compIdentifierNew( $1.string, FALSE );
                  $1.dealloc = FALSE;
               }
               hb_compAutoOpenAdd( $1.string );
            }
            | LITERAL '+' LITERAL {
               char szFileName[ HB_PATH_MAX ];
               hb_strncat( hb_strncpy( szFileName, $1.string, HB_PATH_MAX ), $3.string, HB_PATH_MAX );
               hb_compAutoOpenAdd( hb_compIdentifierNew( szFileName, TRUE ) );
               if( $1.dealloc )
               {
                  hb_xfree( $1.string );
                  $1.dealloc = FALSE;
               }
               if( $3.dealloc )
               {
                  hb_xfree( $3.string );
                  $3.dealloc = FALSE;
               }
            }
            ;

Function   : FunScope FUNCTION  IdentName
             {
                hb_comp_cVarType = ' ';
                hb_comp_bVarParams = FALSE;
             }
             Params
             ImplementsNamespace
             {
                hb_compFunctionAdd( $3, ( HB_SYMBOLSCOPE ) $1, 0 );

                if( hb_comp_bVarParams )
                {
                   hb_comp_functions.pLast->pCode[2] = HB_VAR_PARAM_FLAG;
                }
                else
                {
                   while( hb_comp_LocalParams )
                   {
                      PLOCALPARAM pDelete = hb_comp_LocalParams;

                      hb_compVariableAdd( hb_comp_LocalParams->szName, hb_comp_LocalParams->cType );

                      hb_comp_LocalParams = hb_comp_LocalParams->pNext;
                      hb_xfree( (void *) pDelete );
                   }
                }

                if( $6 )
                {
                   hb_compNamespaceEnd();
                }
             }
             Crlf
             {
                hb_comp_wSeqCounter      = 0;
                hb_comp_wForCounter      = 0;
                hb_comp_wIfCounter       = 0;
                hb_comp_wWhileCounter    = 0;
                hb_comp_wCaseCounter     = 0;
                hb_comp_wWithObjCounter  = 0;
                hb_comp_wSwitchCounter   = 0;
                hb_comp_wFinallyCounter  = 0;
             }
           | FunScope PROCEDURE IdentName
             {
                hb_comp_cVarType = ' ';
                hb_comp_bVarParams = FALSE;
             }
             Params
             ImplementsNamespace
             {
                hb_compFunctionAdd( $3, ( HB_SYMBOLSCOPE ) $1, FUN_PROCEDURE );

                if( hb_comp_bVarParams )
                {
                   hb_comp_functions.pLast->pCode[2] = HB_VAR_PARAM_FLAG;
                }
                else
                {
                   while( hb_comp_LocalParams )
                   {
                      PLOCALPARAM pDelete = hb_comp_LocalParams;

                      hb_compVariableAdd( hb_comp_LocalParams->szName, hb_comp_LocalParams->cType );

                      hb_comp_LocalParams = hb_comp_LocalParams->pNext;
                      hb_xfree( (void *) pDelete );
                   }
                }

                if( $6 )
                {
                   hb_compNamespaceEnd();
                }
             }
             Crlf
             {
                hb_comp_wSeqCounter      = 0;
                hb_comp_wForCounter      = 0;
                hb_comp_wIfCounter       = 0;
                hb_comp_wWhileCounter    = 0;
                hb_comp_wCaseCounter     = 0;
                hb_comp_wWithObjCounter  = 0;
                hb_comp_wSwitchCounter   = 0;
                hb_comp_wFinallyCounter  = 0;
             }
           ;

FunScope   :                  { $$ = HB_FS_PUBLIC; }
           | STATIC           { $$ = HB_FS_STATIC; }
           | UTILITY          { $$ = ( HB_FS_UTILITY | HB_FS_PUBLIC ); }
           | UTILITY STATIC   { $$ = ( HB_FS_UTILITY | HB_FS_STATIC ); }
           | INIT             { $$ = HB_FS_INIT; }
           | EXIT             { $$ = HB_FS_EXIT; }
           | CRITICAL         { $$ = HB_FS_CRITICAL | HB_FS_PUBLIC; }
           | CRITICAL_STATIC  { $$ = ( HB_FS_CRITICAL | HB_FS_STATIC ); }
           ;

Params     :
           | '(' ')'
           | '(' { hb_comp_iVarScope = VS_PARAMETER; } ParamList ')'
           | '(' EPSILON ')'                                         { hb_comp_bVarParams = TRUE; }
           ;

AsType     : /* not specified */           { hb_comp_cVarType = ' '; }
           | StrongType
           ;

StrongType : AS_NUMERIC                    { hb_comp_cVarType = 'N'; }
           | AS_CHARACTER                  { hb_comp_cVarType = 'C'; }
           | AS_DATE                       { hb_comp_cVarType = 'D'; }
           | AS_LOGICAL                    { hb_comp_cVarType = 'L'; }
           | AS_BLOCK                      { hb_comp_cVarType = 'B'; }
           | AS_OBJECT                     { hb_comp_cVarType = 'O'; }
           | AS_CLASS IdentName            { hb_comp_cVarType = 'S'; hb_comp_szFromClass = $2; }
           | AS_ENUM IdentName             { hb_comp_cVarType = 'E'; hb_comp_szFromEnum = $2; }
           | AS_VARIANT                    { hb_comp_cVarType = ' '; }
           | AsArray
           ;

AsArray    : AS_ARRAY                      { hb_comp_cVarType = 'A'; }
           | AS_NUMERIC_ARRAY              { hb_comp_cVarType = 'n'; }
           | AS_CHARACTER_ARRAY            { hb_comp_cVarType = 'c'; }
           | AS_DATE_ARRAY                 { hb_comp_cVarType = 'd'; }
           | AS_LOGICAL_ARRAY              { hb_comp_cVarType = 'l'; }
           | AS_ARRAY_ARRAY                { hb_comp_cVarType = 'a'; }
           | AS_BLOCK_ARRAY                { hb_comp_cVarType = 'b'; }
           | AS_OBJECT_ARRAY               { hb_comp_cVarType = 'o'; }
           | AS_CLASS_ARRAY IdentName      { hb_comp_cVarType = 's'; hb_comp_szFromClass = $2; }
           | AS_ENUM_ARRAY IdentName       { hb_comp_cVarType = 'e'; hb_comp_szFromEnum = $2; }
           ;

ParamList  : IdentName AsType                {
                                               hb_comp_LocalParams = (PLOCALPARAM) hb_xgrab( sizeof( LOCALPARAM ) );
                                               hb_comp_LocalParams->szName = $1;
                                               hb_comp_LocalParams->cType  = hb_comp_cVarType;
                                               hb_comp_LocalParams->pNext  = NULL;

                                               $$ = (void *) hb_comp_LocalParams;
                                             }
           | ParamList ',' IdentName AsType  {
                                               PLOCALPARAM pLocalParam = (PLOCALPARAM) hb_xgrab( sizeof( LOCALPARAM ) );

                                               pLocalParam->szName = $3;
                                               pLocalParam->cType  = hb_comp_cVarType;
                                               pLocalParam->pNext  = NULL;

                                               ( (PLOCALPARAM) $$ )->pNext = pLocalParam;

                                               $$ = (void *) pLocalParam;
                                             }
           ;

ImplementsNamespace : /* Empty */                    { $$ = NULL; }
                    | IMPLEMENTS_NAMESPACE IdentName
                                                     {
                                                       PNAMESPACE pNamespace;

                                                       $$ = $2;

                                                       if( hb_comp_Namespaces.pCurrent )
                                                       {
                                                          hb_compYYError( 'E', HB_COMP_ERR_IMPLEMENTS_IN_NAMESPACE, hb_comp_Namespaces.pCurrent->szName, NULL );
                                                       }

                                                       /* Might be IMPLEMENTS NAMESPACE in same compilation as namespace definition */
                                                       pNamespace = hb_compNamespaceFind( hb_comp_Namespaces.pFirst, $$, NSTYPE_SPACE );

                                                       hb_compNamespaceNew( $$, NSTYPE_STEALTH );

                                                       if( pNamespace )
                                                       {
                                                          hb_comp_Namespaces.pCurrent->iID = pNamespace->iID;
                                                       }
                                                     }
                    ;

/* NOTE: This allows the use of Expression as a statement.
 *    The Expression is validated later in reduction phase of
 *    hb_compExprGenStatement(). With this solution we don't have to
 *    stop compilation if invalid syntax will be used.
 */
Statement  : ExecFlow { hb_comp_bDontGenLineNum = TRUE; } CrlfStmnt   { }
           | WithObject CrlfStmnt   {}
           | FunCall CrlfStmnt      { hb_compExprDelete( hb_compExprGenStatement( $1 ) ); }
           | AliasExpr CrlfStmnt    { hb_compExprDelete( hb_compExprGenStatement( $1 ) ); }
           | ObjectMethod CrlfStmnt { hb_compExprDelete( hb_compExprGenStatement( $1 ) ); }
           | WithMethod CrlfStmnt   { hb_compExprDelete( hb_compExprGenStatement( $1 ) ); }
           | MacroVar CrlfStmnt     { if( HB_COMP_ISSUPPORTED( HB_COMPFLAG_XBASE ) )
                                         hb_compExprDelete( hb_compExprGenStatement( $1 ) );
                                      else
                                         hb_compExprDelete( hb_compErrorSyntax( $1 ) );
                                     }
           | MacroExpr CrlfStmnt    { if( HB_COMP_ISSUPPORTED( HB_COMPFLAG_XBASE ) )
                                         hb_compExprDelete( hb_compExprGenStatement( $1 ) );
                                      else
                                         hb_compExprDelete( hb_compErrorSyntax( $1 ) );
                                     }
           | PareExpList CrlfStmnt  { hb_compExprDelete( hb_compExprGenStatement( $1 ) ); }
           | ExprPreOp CrlfStmnt    { hb_compExprDelete( hb_compExprGenStatement( $1 ) ); }
           | ExprPostOp CrlfStmnt   { hb_compExprDelete( hb_compExprGenStatement( $1 ) ); }
           | ExprOperEq CrlfStmnt   { hb_compExprDelete( hb_compExprGenStatement( $1 ) ); }
           | ExprEqual CrlfStmnt    { hb_compExprDelete( hb_compExprGenStatement( $1 ) ); }
           | ExprAssign CrlfStmnt   { hb_compExprDelete( hb_compExprGenStatement( $1 ) ); }
           | DoProc CrlfStmnt       { hb_compExprDelete( hb_compExprGenStatement( $1 ) ); }
           | BREAK CrlfStmnt        { hb_compGenBreak(); hb_compGenPCode2( HB_P_DOSHORT, 0, ( BOOL ) 1 );
                                      hb_comp_functions.pLast->bFlags |= FUN_BREAK_CODE; }
           | BREAK { hb_compLinePushIfInside(); } Expression Crlf  { hb_compGenBreak(); hb_compExprDelete( hb_compExprGenPush( $3 ) );
                                           hb_compGenPCode2( HB_P_DOSHORT, 1, ( BOOL ) 1 );
                                           hb_comp_functions.pLast->bFlags |= FUN_BREAK_CODE;
                                         }
           | EXIT      { hb_comp_bDontGenLineNum = !hb_comp_bDebugInfo; } CrlfStmnt { hb_compLoopExit(); hb_comp_functions.pLast->bFlags |= FUN_BREAK_CODE; }
           | LOOP      { hb_comp_bDontGenLineNum = !hb_comp_bDebugInfo; } CrlfStmnt { hb_compLoopLoop(); hb_comp_functions.pLast->bFlags |= FUN_BREAK_CODE; }
           | RETURN CrlfStmnt {
                        if( hb_comp_wSeqCounter )
                        {
                           hb_compYYError( 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "RETURN", NULL );
                        }
                        hb_compGenPCode1( HB_P_ENDPROC );
                        if( (hb_comp_functions.pLast->bFlags & FUN_PROCEDURE) == 0 )
                        { /* return from a function without a return value */
                           hb_compGenWarning( hb_comp_szWarnings, 'W', HB_COMP_WARN_NO_RETURN_VALUE, NULL, NULL );
                        }
                        hb_comp_functions.pLast->bFlags |= FUN_WITH_RETURN;
                        hb_comp_bDontGenLineNum = FALSE;
                        hb_comp_functions.pLast->bFlags |= FUN_BREAK_CODE;
                     }
           | RETURN  {  hb_compLinePushIfInside(); hb_comp_cVarType = ' '; }
             Expression Crlf
                     {
                        hb_comp_cCastType = hb_comp_cVarType;
                        hb_comp_cVarType = ' ';

                        if( hb_comp_wSeqCounter )
                        {
                           hb_compYYError( 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "RETURN", NULL );
                        }

                        hb_compExprDelete( hb_compExprGenPush( $3 ) );   /* TODO: check if return value agree with declared value */

                        hb_compGenPCode2( HB_P_RETVALUE, HB_P_ENDPROC, ( BOOL ) 1 );

                        if( hb_comp_functions.pLast->bFlags & FUN_PROCEDURE )
                        { /* procedure returns a value */
                           hb_compGenWarning( hb_comp_szWarnings, 'W', HB_COMP_WARN_PROC_RETURN_VALUE, NULL, NULL );
                        }

                        hb_comp_functions.pLast->bFlags |= FUN_WITH_RETURN;
                        hb_comp_bDontGenLineNum = FALSE;
                        hb_comp_functions.pLast->bFlags |= FUN_BREAK_CODE;
                     }
           | PUBLIC { hb_compLinePushIfInside(); hb_comp_iVarScope = VS_PUBLIC; }
                     ExtVarList
                    { hb_compRTVariableGen( hb_compExpr_IDs.__MVPUBLIC ); hb_comp_cVarType = ' ';  hb_comp_iVarScope = VS_NONE; } Crlf
           | PRIVATE { hb_compLinePushIfInside(); hb_comp_iVarScope = VS_PRIVATE; }
                     ExtVarList
                    { hb_compRTVariableGen( hb_compExpr_IDs.__MVPRIVATE ); hb_comp_cVarType = ' '; hb_comp_iVarScope = VS_NONE; } Crlf

           | EXTERN ExtList Crlf
           | DYNAMIC DynList Crlf
           | ANNOUNCE IdentName
                                {
                                  if( hb_comp_szAnnounce == NULL )
                                  {
                                     /* check for reserved name
                                     * NOTE: Clipper doesn't check for it
                                     */
                                     char * szFunction = hb_compReservedName( $2 );

                                     if( szFunction )
                                     {
                                        hb_compYYError( 'E', HB_COMP_ERR_FUNC_RESERVED, szFunction, $2 );
                                     }

                                     hb_comp_szAnnounce = $2;
                                  }
                                  else
                                  {
                                     hb_compGenWarning( hb_comp_szWarnings, 'W', HB_COMP_WARN_DUPL_ANNOUNCE, $2, NULL );
                                  }
                                }
             Crlf
           | error  { if( hb_comp_bError == FALSE ) { yyerror( NULL ); }; } Crlf  { yyclearin; yyerrok; }
           | PARAMETERS { if( hb_comp_functions.pLast->bFlags & FUN_USES_LOCAL_PARAMS )
                          {
                             hb_compYYError( 'E', HB_COMP_ERR_PARAMETERS_NOT_ALLOWED, NULL, NULL );
                          }
                          else
                          {
                             hb_comp_functions.pLast->wParamNum = 0; hb_comp_iVarScope = ( VS_PRIVATE | VS_PARAMETER );
                          }
                        }
                        MemvarList Crlf { hb_comp_iVarScope = VS_NONE; }

           | DIVERT Expression DivertFlags CrlfStmnt
             {
               hb_compExprDelete( hb_compExprGenPush( $2 ) );
               hb_compExprDelete( hb_compExprGenPush( $3 ) );
               hb_compGenPCode1( HB_P_DIVERT );
             }
           | DIVERT Expression OF Expression DivertFlags CrlfStmnt
             {
               hb_compExprDelete( hb_compExprGenPush( $4 ) );
               hb_compExprDelete( hb_compExprGenPush( $2 ) );
               hb_compExprDelete( hb_compExprGenPush( $5 ) );
               hb_compGenPCode1( HB_P_DIVERTOF );
             }
           ;

DivertFlags: /* No Flags */ { $$ = hb_compExprNewLong(0); }
           | FLAGS Expression { $$ = $2; }
           ;

CrlfStmnt  : { hb_compLinePushIfInside(); } Crlf
           ;

LineStat   : Crlf          { $<lNumber>$ = 0; }
           | Line          { $<lNumber>$ = 0; }
           | Statement     { $<lNumber>$ = 1; }
           | Declaration   { $<lNumber>$ = 1; }
           | ControlError  { char LineAsString[32]; hb_snprintf( LineAsString, sizeof( LineAsString ), "at line %i", s_iLastControlLine - 1 ); hb_compYYError( 'E', HB_COMP_ERR_UNCLOSED_STRU, LineAsString, NULL ); }
           ;

ControlError : FunScope2 FUNCTION  IdentName Params Crlf {}
             | FunScope2 PROCEDURE IdentName Params Crlf {}
             ;

FunScope2  :
           | STATIC
           | INIT
           | EXIT
           | CRITICAL
           | CRITICAL_STATIC
           ;

Statements : LineStat                  { $<lNumber>$ = $<lNumber>1; }
           | Statements LineStat       { $<lNumber>$ += $<lNumber>2; }
           ;

ExtList    : IdentName                      { hb_compExternAdd( $1, NULL, (HB_SYMBOLSCOPE) 0 ); }
           | NamespacePath IdentName        { hb_compExternAdd( $2, $1, (HB_SYMBOLSCOPE) 0 ); }
           | ExtList ',' IdentName          { hb_compExternAdd( $3, NULL, (HB_SYMBOLSCOPE) 0 ); }
           | ExtList ',' NamespacePath IdentName { hb_compExternAdd( $4, $3, (HB_SYMBOLSCOPE) 0 ); }
           ;

DynList    : IdentName                           { hb_compExternAdd( $1, NULL, HB_FS_DEFERRED ); }
           | NamespacePath IdentName             { hb_compExternAdd( $2, $1, HB_FS_DEFERRED ); }
           | DynList ',' IdentName               { hb_compExternAdd( $3, NULL, HB_FS_DEFERRED ); }
           | DynList ',' NamespacePath IdentName { hb_compExternAdd( $4, $3, HB_FS_DEFERRED ); }
           ;

IdentName  : IDENTIFIER       { $$ = $1; }
           ;

/* Numeric values
 */
NumValue   : NUM_DOUBLE          { $$ = hb_compExprNewDouble( $1.dNumber, $1.bWidth, $1.bDec ); }
           | NUM_INTEGER         { $$ = hb_compExprNewLong( $1.iNumber ); }
           | NUM_LONG            { $$ = hb_compExprNewLong( $1.lNumber ); }
           ;

NumAlias   : NUM_INTEGER  ALIASOP      { $$ = hb_compExprNewLong( $1.iNumber ); }
           | NUM_LONG     ALIASOP      { $$ = hb_compExprNewLong( $1.lNumber ); }
           | NUM_DOUBLE   ALIASOP      { $$ = hb_compErrorAlias( hb_compExprNewDouble( $1.dNumber, $1.bWidth, $1.bDec ) ); }
           ;

/* NULL flag
*/
//NullValue  : NULLVALUE                { $$ = hb_compExprNewNull(); }
//;

/* NIL value
 */
NilValue   : NIL                      { $$ = hb_compExprNewNil(); }
;

NilAlias   : NilValue ALIASOP         { $$ = $1; }
;

/* Literal string value
 */
LiteralValue : LITERAL                {
                                         $$ = hb_compExprNewString( $1.string, $1.length, $1.dealloc );
                                         $1.dealloc = FALSE;

                                         if( bTrancuateBaseArray && pBaseArrayName == NULL )
                                         {
                                            char *pCopy = hb_strdup( $1.string ), *pTmp = strchr( pCopy, '[' );

                                            if( pTmp )
                                            {
                                               pCopy[ pTmp - pCopy ] = '\0';
                                               pBaseArrayName = hb_compExprNewString( pCopy, pTmp - pCopy, TRUE );
                                            }
                                            else
                                               hb_xfree( pCopy );

                                            bTrancuateBaseArray = FALSE;
                                         }
                                      }
             ;

LiteralAlias : LiteralValue ALIASOP       { $$ = $1; }
             ;

/* Codeblock value
 */
CodeBlockAlias : CodeBlock ALIASOP     { $$ = $1; }
;

/* Logical value
 */
Logical    : TRUEVALUE                    { $$ = hb_compExprNewLogical( TRUE ); }
           | FALSEVALUE                   { $$ = hb_compExprNewLogical( FALSE ); }
           ;

LogicalAlias : Logical ALIASOP      { $$ = $1; }
;

/* SELF value and expressions
 */
SelfValue  : SELF             { $$ = hb_compExprNewSelf(); }
;

SelfAlias  : SelfValue ALIASOP         { $$ = $1; }
;

/* Literal date, time & datetime
 */
Date       : '{' POWER NumValue '/' NumValue '/' NumValue '}'
                              { $$ = hb_compExprNewDate( $3, $5, $7 );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                     hb_compExprDelete( $7 );
                              }
           ;

DateAlias  : Date ALIASOP         { $$ = $1; }
;

DateTime   : '{' POWER NumValue '/' NumValue '/' NumValue NumValue ':' NumValue ':' NumValue '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( $3, $5, $7, $8, $10, $12, 0, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                     hb_compExprDelete( $7 );
                                     hb_compExprDelete( $8 );
                                     hb_compExprDelete( $10 );
                                     hb_compExprDelete( $12 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
           | '{' POWER NumValue '/' NumValue '/' NumValue  NumValue ':' NumValue '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( $3, $5, $7, $8, $10, NULL, 0, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                     hb_compExprDelete( $7 );
                                     hb_compExprDelete( $8 );
                                     hb_compExprDelete( $10 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
           | '{' POWER NumValue '/' NumValue '/' NumValue  NumValue ':' NumValue ':' NumValue H12AM '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( $3, $5, $7, $8, $10, $12, 1, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                     hb_compExprDelete( $7 );
                                     hb_compExprDelete( $8 );
                                     hb_compExprDelete( $10 );
                                     hb_compExprDelete( $12 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
           | '{' POWER NumValue '/' NumValue '/' NumValue  NumValue ':' NumValue H12AM '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( $3, $5, $7, $8, $10, NULL, 1, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                     hb_compExprDelete( $7 );
                                     hb_compExprDelete( $8 );
                                     hb_compExprDelete( $10 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
           | '{' POWER NumValue '/' NumValue '/' NumValue  NumValue ':' NumValue ':' NumValue H12PM '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( $3, $5, $7, $8, $10, $12, 2, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                     hb_compExprDelete( $7 );
                                     hb_compExprDelete( $8 );
                                     hb_compExprDelete( $10 );
                                     hb_compExprDelete( $12 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
           | '{' POWER NumValue '/' NumValue '/' NumValue  NumValue ':' NumValue H12PM '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( $3, $5, $7, $8, $10, NULL, 2, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                     hb_compExprDelete( $7 );
                                     hb_compExprDelete( $8 );
                                     hb_compExprDelete( $10 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
           | '{' POWER NumValue ':' NumValue ':' NumValue '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( NULL, NULL, NULL, $3, $5, $7, 0, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                     hb_compExprDelete( $7 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
           | '{' POWER NumValue ':' NumValue '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( NULL, NULL, NULL, $3, $5, NULL, 0, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
           | '{' POWER NumValue ':' NumValue ':' NumValue H12AM '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( NULL, NULL, NULL, $3, $5, $7, 1, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                     hb_compExprDelete( $7 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
           | '{' POWER NumValue ':' NumValue H12AM '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( NULL, NULL, NULL, $3, $5, NULL, 1, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
           | '{' POWER NumValue ':' NumValue ':' NumValue H12PM '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( NULL, NULL, NULL, $3, $5, $7, 2, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                     hb_compExprDelete( $7 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
           | '{' POWER NumValue ':' NumValue H12PM '}'
                              { int iOk = 0;
                                $$ = hb_compExprNewDateTime( NULL, NULL, NULL, $3, $5, NULL, 2, &iOk );
                                     hb_compExprDelete( $3 );
                                     hb_compExprDelete( $5 );
                                if( !iOk )
                                {
                                   $$ = NULL;
                                }
                              }
;

DateTimeAlias : DateTime ALIASOP         { $$ = $1; }
;


/* Literal array
 */
Array      : '{' ArgList '}'          { $$ = hb_compExprNewArray( $2 ); }
           ;

Hash       : '{' HashList '}'         { $$ = hb_compExprNewFunCall( hb_compExprNewFunName( hb_compExpr_IDs.HASH ), $2 ); }
           ;

HashList   : /* nothing => nil */ HASHOP /* nothing => nil */    { $$ = NULL; }
           | Expression HASHOP EmptyExpression                   { $$ = hb_compExprAddListExpr( hb_compExprNewArgList( $1 ), $3 ); }
           | HashList ',' Expression HASHOP EmptyExpression { $$ = hb_compExprAddListExpr( hb_compExprAddListExpr( $1, $3 ), $5 ); }
           ;

ArrayAlias  : Array ALIASOP            { $$ = $1; }
;

/* Literal array access
 */
ArrayAt     : Array ArrayIndex        { $$ = $2; }
            | LiteralValue ArrayIndex { $$ = $2; }
;

ArrayAtAlias : ArrayAt ALIASOP      { $$ = $1; }
;

/* Variables
 */
Variable    : IdentName         {
                                   $$ = hb_compExprNewVar( $1 );

                                   if( hb_comp_BlocksList )
                                   {
                                      PHB_CBVAR pVar = ( PHB_CBVAR ) hb_comp_BlocksList->pBlock->value.asList.pIndex;

                                      while( pVar )
                                      {
                                         if( pVar->szName && HB_EXPR_ISEQUAL_IDS( $1, pVar->szName ) )
                                         {
                                            break;
                                         }

                                         pVar = pVar->pNext;
                                      }

                                      if( pVar == NULL )
                                      {
                                         s_bBlockDeclared = ( s_bBlockDeclared ||
                                                              hb_compLocalGetPos( $1 ) ||
                                                              hb_compStaticGetPos( $1, hb_comp_functions.pLast ) ||
                                                              hb_compVariableGetPos( hb_comp_pGlobals, $1 ) ||
                                                              ( hb_comp_bStartProc == FALSE && hb_compStaticGetPos( $1, hb_comp_functions.pFirst ) ) );
                                      }
                                   }
                                }
;

VarAlias    : IdentName ALIASOP      { $$ = hb_compExprNewAlias( $1 ); }
;

/* Macro variables
 */
MacroVar    : MACROVAR        {
                                $$ = hb_compExprNewMacro( NULL, '&', $1 );

                                if( hb_comp_BlocksList )
                                {
                                   s_bBlockDeclared = ( s_bBlockDeclared ||
                                                        hb_compLocalGetPos( $1 ) ||
                                                        hb_compStaticGetPos( $1, hb_comp_functions.pLast ) ||
                                                        hb_compVariableGetPos( hb_comp_pGlobals, $1 ) ||
                                                        ( hb_comp_bStartProc == FALSE && hb_compStaticGetPos( $1, hb_comp_functions.pFirst ) ) );
                                   s_bBlockMacro = TRUE;
                                }
                              }
            | MacroText       { // Was: MACROTEXT befvore optimization.
                                //$$ = hb_compExprNewMacro( NULL, 0, $1 );
                                $$ = $1;
                              }
            ;

MacroText   : MACROTEXT {
                           HB_EXPR_PTR pPlus = NULL, pLeft = NULL, pRight, pDestExpr;
                           char *pPosition = $1, *pStart, *sToken;
                           BOOL bVar;

                           if( *pPosition == '&' )
                           {
                              bVar = TRUE;
                              pPosition++;
                           }
                           else
                           {
                              bVar = FALSE;
                           }

                           pStart = pPosition;

                           while( *pPosition )
                           {
                              if( *pPosition == '&' )
                              {
                                 *pPosition = '\0';
                                 sToken = hb_compIdentifierNew( pStart, TRUE );
                                 //printf( "\n%s: '%s'\n", bVar ? "Var" : "String", sToken );
                                 pDestExpr = ( bVar ? hb_compExprNewVar( sToken ) : hb_compExprNewString( sToken, strlen( sToken ), FALSE ) );

                                 if( pPlus )
                                 {
                                    pRight = pDestExpr;
                                    pPlus  = hb_compExprSetOperand( hb_compExprNewPlus( pPlus ), pRight );
                                 }
                                 else if( pLeft )
                                 {
                                    pRight = pDestExpr;
                                    pPlus  = hb_compExprSetOperand( hb_compExprNewPlus( pLeft ), pRight );
                                 }
                                 else
                                 {
                                    pLeft = pDestExpr;
                                 }

                                 bVar = TRUE;
                                 pPosition++;
                                 pStart = pPosition;
                                 continue;
                              }
                              else if( *pPosition == '.' )
                              {
                                 if( ! bVar )
                                 {
                                    hb_compYYError( 'E', HB_COMP_ERR_SYNTAX, pPosition, NULL );
                                 }

                                 *pPosition = '\0';
                                 sToken = hb_compIdentifierNew( pStart, TRUE );
                                 //printf( "\n%s: '%s'\n", bVar ? "Var" : "String", sToken );
                                 pDestExpr = ( bVar ? hb_compExprNewVar( sToken ) : hb_compExprNewString( sToken, strlen( sToken ), FALSE ) );

                                 if( pPlus )
                                 {
                                    pRight = pDestExpr;
                                    pPlus  = hb_compExprSetOperand( hb_compExprNewPlus( pPlus ), pRight );
                                 }
                                 else if( pLeft )
                                 {
                                    pRight = pDestExpr;
                                    pPlus  = hb_compExprSetOperand( hb_compExprNewPlus( pLeft ), pRight );
                                 }
                                 else
                                 {
                                    pLeft = pDestExpr;
                                 }

                                 bVar = FALSE;
                                 pPosition++;
                                 pStart = pPosition;
                                 continue;
                              }

                              pPosition++;
                           }

                           sToken = hb_compIdentifierNew( pStart, TRUE );
                           //printf( "\nLast - %s: '%s'\n\n\n", bVar ? "Var" : "String", sToken );
                           pDestExpr = ( bVar ? hb_compExprNewVar( sToken ) : hb_compExprNewString( sToken, strlen( sToken ), FALSE ) );

                           if( pPlus )
                           {
                              pRight = pDestExpr;
                              pPlus  = hb_compExprSetOperand( hb_compExprNewPlus( pPlus ), pRight );
                           }
                           else if( pLeft )
                           {
                              pRight = pDestExpr;
                              pPlus  = hb_compExprSetOperand( hb_compExprNewPlus( pLeft ), pRight );
                           }
                           else
                           {
                              pPlus = pDestExpr;
                              hb_compYYError( 'E', HB_COMP_ERR_SYNTAX, sToken, NULL );
                           }

                           $$ = hb_compExprNewMacro( hb_compExprNewList( pPlus ), 0, NULL );
                           hb_xfree( $1 );
                         }
            ;

MacroVarAlias  : MacroVar ALIASOP   { $$ = $1; }
;

/* Macro expressions
 */
MacroExpr  : '&' PareExpList       { $$ = hb_compExprNewMacro( $2, 0, NULL ); }
;

MacroExprAlias : MacroExpr ALIASOP     { $$ = $1; }
;

/* Aliased variables
 */
/* special case: _FIELD-> and FIELD-> can be nested
 */
FieldAlias  : FIELD ALIASOP               { $$ = hb_compExprNewAlias( hb_compExpr_IDs.FIELD_ ); }
            | FIELD ALIASOP FieldAlias    { $$ = $3; }
            ;

/* ignore _FIELD-> or FIELD-> if a real alias is specified
 */
FieldVarAlias  : FieldAlias VarAlias            { hb_compExprDelete( $1 ); $$ = $2; }
               | FieldAlias NumAlias            { hb_compExprDelete( $1 ); $$ = $2; }
               | FieldAlias PareExpListAlias    { hb_compExprDelete( $1 ); $$ = $2; }
               | FieldAlias MacroVarAlias       { hb_compExprDelete( $1 ); $$ = $2; }
               | FieldAlias MacroExprAlias      { hb_compExprDelete( $1 ); $$ = $2; }
               | FieldAlias NilAlias            { hb_compExprDelete( $1 ); $$ = hb_compErrorAlias( $2 ); }
               | FieldAlias LiteralAlias        { hb_compExprDelete( $1 ); $$ = hb_compErrorAlias( $2 ); }
               | FieldAlias LogicalAlias        { hb_compExprDelete( $1 ); $$ = hb_compErrorAlias( $2 ); }
               | FieldAlias DateAlias           { hb_compExprDelete( $1 ); $$ = hb_compErrorAlias( $2 ); }
               | FieldAlias DateTimeAlias       { hb_compExprDelete( $1 ); $$ = hb_compErrorAlias( $2 ); }
               | FieldAlias CodeBlockAlias      { hb_compExprDelete( $1 ); $$ = hb_compErrorAlias( $2 ); }
               | FieldAlias SelfAlias           { hb_compExprDelete( $1 ); $$ = hb_compErrorAlias( $2 ); }
               | FieldAlias ArrayAlias          { hb_compExprDelete( $1 ); $$ = hb_compErrorAlias( $2 ); }
               | FieldAlias ArrayAtAlias        { hb_compExprDelete( $1 ); $$ = hb_compErrorAlias( $2 ); }
               ;

AliasId     : IdentName      { $$ = hb_compExprNewVar( $1 ); }
            | MacroVar        { $$ = $1; }
            | MacroExpr       { $$ = $1; }
            ;

AliasVar   : NumAlias AliasId          { $$ = hb_compExprNewAliasVar( $1, $2 ); }
           | MacroVarAlias AliasId     { $$ = hb_compExprNewAliasVar( $1, $2 ); }
           | MacroExprAlias AliasId    { $$ = hb_compExprNewAliasVar( $1, $2 ); }
           | PareExpListAlias AliasId  { $$ = hb_compExprNewAliasVar( $1, $2 ); }
           | NilAlias AliasId          { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }
           | LiteralAlias AliasId      { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }
           | LogicalAlias AliasId      { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }
           | DateAlias AliasId         { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }
           | DateTimeAlias AliasId     { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }
           | CodeBlockAlias AliasId    { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }
           | SelfAlias AliasId         { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }
           | ArrayAlias AliasId        { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }
           | ArrayAtAlias AliasId      { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }  /* QUESTION: Clipper reports error here - we can handle this */
           | VariableAtAlias AliasId   { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }  /* QUESTION: Clipper reports error here - we can handle this */
           | FunCallAlias AliasId      { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }  /* QUESTION: Clipper reports error here - we can handle this */
           | ObjectDataAlias AliasId   { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }  /* QUESTION: Clipper reports error here - we can handle this */
           | ObjectMethodAlias AliasId { $$ = hb_compErrorAlias( $1 ); hb_compExprDelete($2); }  /* QUESTION: Clipper reports error here - we can handle this */
           | VarAlias AliasId          { $$ = hb_compExprNewAliasVar( $1, $2 ); }
           | FieldAlias AliasId        { $$ = hb_compExprNewAliasVar( $1, $2 ); }
           | FieldVarAlias AliasId     { $$ = hb_compExprNewAliasVar( $1, $2 ); }
           ;

/* Aliased expressions
 */
/* NOTE: In the case:
 * alias->( Expression )
 * alias always selects a workarea at runtime
 */
AliasExpr  : NumAlias PareExpList         { $$ = hb_compExprNewAliasExpr( $1, $2 ); }
           | VarAlias PareExpList         { $$ = hb_compExprNewAliasExpr( $1, $2 ); }
           | MacroVarAlias PareExpList    { $$ = hb_compExprNewAliasExpr( $1, $2 ); }
           | MacroExprAlias PareExpList   { $$ = hb_compExprNewAliasExpr( $1, $2 ); }
           | PareExpListAlias PareExpList { $$ = hb_compExprNewAliasExpr( $1, $2 ); }
           | FieldAlias PareExpList       { $$ = hb_compErrorAlias( $2 ); } /* QUESTION: Clipper reports error here - we can handle it */
           ;

/* Array expressions access
 */
VariableAt  : NilValue      ArrayIndex    { $$ = $2; }
            | CodeBlock     ArrayIndex    { $$ = $2; }
            | Logical       ArrayIndex    { $$ = $2; }
            | Date          ArrayIndex    { $$ = $2; }
            | DateTime      ArrayIndex    { $$ = $2; }
            | SelfValue     ArrayIndex    { $$ = $2; }
            | Variable      ArrayIndex    { $$ = $2; }
            | AliasVar      ArrayIndex    { $$ = $2; }
            | AliasExpr     ArrayIndex    { $$ = $2; }
            | MacroVar      ArrayIndex    { $$ = $2; }
            | MacroExpr     ArrayIndex    { $$ = $2; }
            | ObjectData    ArrayIndex    { $$ = $2; }
            | ObjectMethod  ArrayIndex    { $$ = $2; }
            | WithData      ArrayIndex    { $$ = $2; }
            | WithMethod    ArrayIndex    { $$ = $2; }
            | FunCall       ArrayIndex    { $$ = $2; }
            | PareExpList   ArrayIndex    { $$ = $2; }
            | Hash          ArrayIndex    { $$ = $2; }
            ;

VariableAtAlias : VariableAt ALIASOP      { $$ = $1; }
;


NamespacePath : NamespaceName '.'           { $$ = $1; }
              | NamespacePath IdentName '.' { /* IdentName not NamespaceName is intentional - we don't want Global -> except when 1st! */
                                              if( $1[0] == '*' )
                                              {
                                                 hb_compYYError( 'E', HB_COMP_ERR_NONMEMBER_NAMESPACE, $2, "*" );
                                                 $$ = $1;
                                              }
                                              else
                                              {
                                                 char *szNamespace = (char *) hb_xgrab( strlen( $1 ) + 1 + strlen( $2 ) + 1 );

                                                 hb_xstrcpy( szNamespace, $1, ".", $2, NULL );
                                                 $$ = hb_compIdentifierNew( szNamespace, FALSE );
                                              }
                                            }
           ;

/* Function call
 */
FunCall    : IdentName '(' ArgList ')' { $$ = hb_compExprNewFunCall( hb_compExprNewFunName( $1 ), $3 ); }
           | NamespacePath IdentName '(' ArgList ')' { $$ = hb_compExprNewFunCall( hb_compExprNewNamespaceFunName( $1, $2 ), $4 ); }
           | MacroVar '(' ArgList ')'  { $$ = hb_compExprNewFunCall( $1, $3 ); }
           | MacroExpr '(' ArgList ')' { $$ = hb_compExprNewFunCall( $1, $3 ); }
           | Get                       { $$ = $1; }
           | IIFInline                 { $$ = $1; }
           ;

ArgList    : Argument                  { $$ = hb_compExprNewArgList( $1 ); }
           | ArgList ',' Argument      { $$ = hb_compExprAddListExpr( $1, $3 ); }
           ;

Argument   :  EmptyExpression          { $$ = $1; }
           | '@' Expression            {
                                          switch( $2->ExprType )
                                          {
                                             case HB_ET_VARIABLE:
                                               $$ = $2;
                                               $$->ExprType = HB_ET_VARREF;
                                               $$->ValType = HB_EV_VARREF;
                                               break;

                                             case HB_ET_ALIASVAR:
                                             {
                                               char *szAlias = $2->value.asAlias.pAlias->value.asSymbol.szName;

                                               if( strcmp( szAlias, "M" ) == 0 || strncmp( szAlias, "MEMVAR", 4 > strlen( szAlias ) ? 4 : strlen( szAlias ) ) == 0 )
                                               {
                                                  $$ = $2->value.asAlias.pVar;

                                                  $2->value.asAlias.pVar = NULL;
                                                  hb_compExprDelete( $2 );

                                                  if( $$->ExprType == HB_ET_MACRO )
                                                  {
                                                     $$->value.asMacro.SubType = HB_ET_MACRO_VAR_REF;
                                                  }
                                                  else
                                                  {
                                                     $$->ExprType = HB_ET_MEMVARREF;
                                                     $$->ValType = HB_EV_VARREF;
                                                  }
                                               }
                                               break;
                                             }

                                             case HB_ET_FUNCALL:
                                               $$ = $2->value.asFunCall.pFunName;

                                               $2->value.asFunCall.pFunName = NULL;
                                               hb_compExprDelete( $2 );

                                               $$->ExprType = HB_ET_FUNREF;
                                               $$->ValType = HB_EV_FUNREF;
                                               break;

                                             case HB_ET_SEND:
                                               $$ = $2;
                                               $$->value.asMessage.bByRef = TRUE;
                                               break;

                                             case HB_ET_MACRO:
                                               $$ = $2;
                                               $$->value.asMacro.SubType = HB_ET_MACRO_VAR_REF;
                                               break;

                                             case HB_ET_ARRAYAT:
                                               $$ = $2;
                                               $$->value.asList.bByRef = TRUE;
                                               break;

                                             default:
                                               hb_compYYError( 'E', HB_COMP_ERR_INVALID_REFER, hb_compExprDescription( $2 ), NULL );
                                               $$ = NULL;
                                          }
                                       }
           ;

DummyArgList : DummyArgument                  {}
             | DummyArgList ',' DummyArgument {}
             ;

DummyArgument : EmptyExpression                    { hb_compExprDelete($1); }
              | '@' IdentName                      {}
              | '@' IdentName '(' DummyArgList ')' {}
              ;

FunCallAlias : FunCall ALIASOP        { $$ = $1; }
;

/* Object's instance variable
 */
SendId      : IdentName      { $$ = hb_compExprNewFunName( $1 ); }
            | MacroVar       { $$ = $1; $1->value.asMacro.SubType = HB_ET_MACRO_SYMBOL; }
            | MacroExpr      { $$ = $1; $1->value.asMacro.SubType = HB_ET_MACRO_SYMBOL; }
            ;

ObjectData  : NumValue ':' SendId        { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | NilValue ':' SendId        { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | LiteralValue ':' SendId    { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | CodeBlock ':' SendId       { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | Logical ':' SendId         { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | Date ':' SendId            { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | DateTime ':' SendId        { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | SelfValue ':' SendId       { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | Array ':' SendId           { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | Hash ':' SendId            { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | ArrayAt ':' SendId         { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | Variable ':' SendId        { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | AliasVar ':' SendId        { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | AliasExpr ':' SendId       { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | MacroVar ':' SendId        { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | MacroExpr ':' SendId       { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | FunCall ':' SendId         { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | PareExpList ':' SendId     { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | VariableAt ':' SendId      { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | ObjectMethod ':' SendId    { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | ObjectData ':' SendId      { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | WithMethod ':' SendId      { $$ = hb_compExprNewSendExp( $1, $3 ); }
            | WithData ':' SendId        { $$ = hb_compExprNewSendExp( $1, $3 ); }
            ;

WithData    : ':' SendId                 {
                                            if( hb_comp_wWithObjCounter == 0 )
                                            {
                                               if( $2->ExprType == HB_ET_FUNNAME )
                                                  hb_compYYError( 'E', HB_COMP_ERR_UNMATCHED_WITHOBJECT, $2->value.asSymbol.szName, NULL );
                                               else
                                                  hb_compYYError( 'E', HB_COMP_ERR_UNMATCHED_WITHOBJECT, "&", NULL );
                                            }
                                            $$ = hb_compExprNewWithSendExp( $2 );
                                         }
           ;

ObjectDataAlias : ObjectData ALIASOP     { $$ = $1; }
                ;

/* Object's method
 */

ObjectMethod : ObjectData '(' ArgList ')'    { $$ = hb_compExprNewMethodCall( $1, $3 ); }
             ;

WithMethod   : WithData '(' ArgList ')'  {
                                           if( hb_comp_wWithObjCounter == 0 )
                                           {
                                              hb_compYYError( 'E', HB_COMP_ERR_UNMATCHED_WITHOBJECT, $1->value.asMessage.szMessage, NULL );
                                           }
                                           $$ = hb_compExprNewWithMethodCall( $1, $3 );
                                         }
             ;

ObjectMethodAlias : ObjectMethod ALIASOP        { $$ = $1; }
;

/* NOTE: We have to distinguish IdentName here because it is repeated
 * in DoArgument (a part of DO <proc> WITH .. statement)
 * where it generates different action.
 */
SimpleExpression :
             NumValue
           | NilValue                         { $$ = $1; }
           | LiteralValue                     { $$ = $1; }
           | CodeBlock                        { $$ = $1; }
           | CodeBlock2                       { $$ = $1; }
           | Logical                          { $$ = $1; }
           | Date                             { $$ = $1; }
           | DateTime                         { $$ = $1; }
           | SelfValue                        { $$ = $1; }
           | SelfValue    {hb_comp_cVarType = ' ';} StrongType { $$ = $1; }
           | Array                            { $$ = $1; }
           | Hash                             { $$ = $1; }
           | ArrayAt                          { $$ = $1; }
           | AliasVar                         { $$ = $1; }
           | MacroVar                         { $$ = $1; }
           | MacroExpr                        { $$ = $1; }
           | VariableAt                       { $$ = $1; }
           | FunCall                          { $$ = $1; }
           | FunCall      {hb_comp_cVarType = ' ';} StrongType { $$ = $1; }
           | ObjectData                       { $$ = $1; }
           | ObjectData   {hb_comp_cVarType = ' ';} StrongType { $$ = $1; }
           | ObjectMethod                     { $$ = $1; }
           | ObjectMethod {hb_comp_cVarType = ' ';} StrongType { $$ = $1; }
           | WithData                         { $$ = $1; }
           | WithData                         {hb_comp_cVarType = ' ';} StrongType { $$ = $1; }
           | WithMethod                       { $$ = $1; }
           | WithMethod   {hb_comp_cVarType = ' ';} StrongType { $$ = $1; }
           | AliasExpr                        { $$ = $1; }
           | ExprAssign                       { $$ = $1; }
           | ExprOperEq                       { $$ = $1; }
           | ExprPostOp                       { $$ = $1; }
           | ExprPreOp                        { $$ = $1; }
           | ExprUnary                        { $$ = $1; }
           | ExprMath                         { $$ = $1; }
           | ExprBool                         { $$ = $1; }
           | ExprRelation                     { $$ = $1; }
           ;

Expression : Variable         { $$ = $1; }
           | SimpleExpression { $$ = $1; }
           | PareExpList      { $$ = $1; }
           | Variable         { hb_comp_cVarType = ' ';} StrongType { $$ = $1; }
           | PareExpList      { hb_comp_cVarType = ' ';} StrongType { $$ = $1; }
           ;

EmptyExpression: /* nothing => nil */        { $$ = hb_compExprNewEmpty(); }
           | Expression
           ;

LValue      : IdentName                     { $$ = hb_compExprNewVar( $1 ); }
            | AliasVar
            | MacroVar
            | MacroExpr
            | ObjectData
            | WithData
            | VariableAt
            | PareExpList        { $$ = hb_compExprListStrip( $1, NULL ); }
            ;

/* NOTE: PostOp can be used in one context only - it uses $0 rule
 *    (the rule that stands before PostOp)
 */
PostOp      : INC    { $$ = hb_compExprNewPostInc( $<asExpr>0 ); }
            | DEC    { $$ = hb_compExprNewPostDec( $<asExpr>0 ); }
            ;

/* NOTE: The rule: Expression Operator Expression
 * that can be used standalone as a statement have to be written
 * using all possible left values to resolve shift/reduce conflicts
 */
ExprPostOp  : NumValue     PostOp %prec POST  { $$ = $2; }
            | NilValue     PostOp %prec POST  { $$ = $2; }
            | LiteralValue PostOp %prec POST  { $$ = $2; }
            | CodeBlock    PostOp %prec POST  { $$ = $2; }
            | Logical      PostOp %prec POST  { $$ = $2; }
            | Date         PostOp %prec POST  { $$ = $2; }
            | DateTime     PostOp %prec POST  { $$ = $2; }
            | SelfValue    PostOp %prec POST  { $$ = $2; }
            | Array        PostOp %prec POST  { $$ = $2; }
            | Hash         PostOp %prec POST  { $$ = $2; }
            | ArrayAt      PostOp %prec POST  { $$ = $2; }
            | Variable     PostOp %prec POST  { $$ = $2; }
            | MacroVar     PostOp %prec POST  { $$ = $2; }
            | MacroExpr    PostOp %prec POST  { $$ = $2; }
            | AliasVar     PostOp %prec POST  { $$ = $2; }
            | AliasExpr    PostOp %prec POST  { $$ = $2; }
            | VariableAt   PostOp %prec POST  { $$ = $2; }
            | PareExpList  PostOp %prec POST  { $$ = $2; }
            | FunCall      PostOp %prec POST  { $$ = $2; }
            | ObjectData   PostOp %prec POST  { $$ = $2; }
            | ObjectMethod PostOp %prec POST  { $$ = $2; }
            | WithData     PostOp %prec POST  { $$ = $2; }
            | WithMethod   PostOp %prec POST  { $$ = $2; }
            ;

ExprPreOp   : INC Expression  %prec PRE      { $$ = hb_compExprNewPreInc( $2 ); }
            | DEC Expression  %prec PRE      { $$ = hb_compExprNewPreDec( $2 ); }
            ;

ExprUnary   : NOT Expression                 { $$ = hb_compExprNewNot( $2 ); }
            | '-' Expression  %prec UNARY    { $$ = hb_compExprNewNegate( $2 ); }
            | '+' Expression  %prec UNARY    { $$ = $2; }
            ;
/*
ExprAssign  : Expression INASSIGN Expression    { $$ = hb_compExprAssign( $1, $3 ); }
;
*/

ExprAssign  : NumValue     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | NilValue     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | LiteralValue INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | CodeBlock    INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | Logical      INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | Date         INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | DateTime     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | SelfValue    INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | Array        INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | Hash         INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | ArrayAt      INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | Variable     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); hb_comp_cCastType = hb_comp_cVarType; hb_comp_cVarType = ' ';}
            | MacroVar     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | MacroExpr    INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | AliasVar     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | AliasExpr    INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | VariableAt   INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); hb_comp_cCastType = hb_comp_cVarType; hb_comp_cVarType = ' ';}
            | PareExpList  INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | FunCall      INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | ObjectData   INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); hb_comp_cCastType = hb_comp_cVarType; hb_comp_cVarType = ' ';}
            | WithData     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); hb_comp_cCastType = hb_comp_cVarType; hb_comp_cVarType = ' ';}
            | ObjectMethod INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            | WithMethod   INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3 ); }
            ;

ExprEqual   : NumValue     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | NilValue     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | LiteralValue '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | CodeBlock    '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | Logical      '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | Date         '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | DateTime     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | SelfValue    '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | Array        '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | Hash         '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | ArrayAt      '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | Variable     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | MacroVar     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | MacroExpr    '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | AliasVar     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | AliasExpr    '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | VariableAt   '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | PareExpList  '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | FunCall      '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | ObjectData   '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | WithData     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | ObjectMethod '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            | WithMethod   '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3 ); }
            ;

ExprPlusEq  : NumValue     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | NilValue     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | LiteralValue PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | CodeBlock    PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | Logical      PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | Date         PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | DateTime     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | SelfValue    PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | Array        PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | Hash         PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | ArrayAt      PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | Variable     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | MacroVar     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | MacroExpr    PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | AliasVar     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | AliasExpr    PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | VariableAt   PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | PareExpList  PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | FunCall      PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | ObjectData   PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | WithData     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | ObjectMethod PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            | WithMethod   PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1 ), $3 ); }
            ;

ExprMinusEq : NumValue     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | NilValue     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | LiteralValue MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | CodeBlock    MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | Logical      MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | Date         MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | DateTime     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | SelfValue    MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | Array        MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | Hash         MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | ArrayAt      MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | Variable     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | MacroVar     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | MacroExpr    MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | AliasVar     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | AliasExpr    MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | VariableAt   MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | PareExpList  MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | FunCall      MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | ObjectData   MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | WithData     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | ObjectMethod MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            | WithMethod   MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1 ), $3 ); }
            ;

ExprMultEq  : NumValue     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | NilValue     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | LiteralValue MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | CodeBlock    MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | Logical      MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | Date         MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | DateTime     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | SelfValue    MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | Array        MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | Hash         MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | ArrayAt      MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | Variable     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | MacroVar     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | MacroExpr    MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | AliasVar     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | AliasExpr    MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | VariableAt   MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | PareExpList  MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | FunCall      MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | ObjectData   MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | WithData     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | ObjectMethod MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            | WithMethod   MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1 ), $3 ); }
            ;

ExprDivEq   : NumValue     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | NilValue     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | LiteralValue DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | CodeBlock    DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | Logical      DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | Date         DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | DateTime     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | SelfValue    DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | Array        DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | Hash         DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | ArrayAt      DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | Variable     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | MacroVar     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | MacroExpr    DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | AliasVar     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | AliasExpr    DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | VariableAt   DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | PareExpList  DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | FunCall      DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | ObjectData   DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | WithData     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | ObjectMethod DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            | WithMethod   DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1 ), $3 ); }
            ;

ExprModEq   : NumValue     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | NilValue     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | LiteralValue MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | CodeBlock    MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | Logical      MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | Date         MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | DateTime     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | SelfValue    MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | Array        MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | Hash         MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | ArrayAt      MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | Variable     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | MacroVar     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | MacroExpr    MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | AliasVar     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | AliasExpr    MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | VariableAt   MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | PareExpList  MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | FunCall      MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | ObjectData   MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | WithData     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | ObjectMethod MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            | WithMethod   MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1 ), $3 ); }
            ;

ExprExpEq   : NumValue     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | NilValue     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | LiteralValue EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | CodeBlock    EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | Logical      EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | Date         EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | DateTime     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | SelfValue    EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | Array        EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | Hash         EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | ArrayAt      EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | Variable     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | MacroVar     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | MacroExpr    EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | AliasVar     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | AliasExpr    EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | VariableAt   EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | PareExpList  EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | FunCall      EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | ObjectData   EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | WithData     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | ObjectMethod EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            | WithMethod   EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1 ), $3 ); }
            ;

ExprOperEq  : ExprPlusEq        { $$ = $1; }
            | ExprMinusEq       { $$ = $1; }
            | ExprMultEq        { $$ = $1; }
            | ExprDivEq         { $$ = $1; }
            | ExprModEq         { $$ = $1; }
            | ExprExpEq         { $$ = $1; }
            ;

ExprMath    : Expression '+'       Expression { $$ = hb_compExprSetOperand( hb_compExprNewPlus( $1 ), $3 ); }
            | Expression '-'       Expression { $$ = hb_compExprSetOperand( hb_compExprNewMinus( $1 ), $3 ); }
            | Expression '*'       Expression { $$ = hb_compExprSetOperand( hb_compExprNewMult( $1 ), $3 ); }
            | Expression '/'       Expression { $$ = hb_compExprSetOperand( hb_compExprNewDiv( $1 ), $3 ); }
            | Expression '%'       Expression { $$ = hb_compExprSetOperand( hb_compExprNewMod( $1 ), $3 ); }
            | Expression POWER     Expression { $$ = hb_compExprSetOperand( hb_compExprNewPower( $1 ), $3 ); }
            | Expression BITAND    Expression { $$ = hb_compExprSetOperand( hb_compExprNewBitAnd( $1 ), $3 ); }
            | Expression BITOR     Expression { $$ = hb_compExprSetOperand( hb_compExprNewBitOr( $1 ), $3 ); }
            | Expression BITXOR    Expression { $$ = hb_compExprSetOperand( hb_compExprNewBitXOr( $1 ), $3 ); }
            | Expression BITSHIFTR Expression { $$ = hb_compExprSetOperand( hb_compExprNewBitShiftR( $1 ), $3 ); }
            | Expression BITSHIFTL Expression { $$ = hb_compExprSetOperand( hb_compExprNewBitShiftL( $1 ), $3 ); }
            ;

ExprBool    : Expression AND  Expression   { $$ = hb_compExprSetOperand( hb_compExprNewAnd( $1 ), $3 ); }
            | Expression OR   Expression   { $$ = hb_compExprSetOperand( hb_compExprNewOr( $1 ), $3 ); }
            ;

ExprRelation: Expression EQ    Expression  { $$ = hb_compExprSetOperand( hb_compExprNewEQ( $1 ), $3 ); }
            | Expression '<'   Expression  { $$ = hb_compExprSetOperand( hb_compExprNewLT( $1 ), $3 ); }
            | Expression '>'   Expression  { $$ = hb_compExprSetOperand( hb_compExprNewGT( $1 ), $3 ); }
            | Expression LE    Expression  { $$ = hb_compExprSetOperand( hb_compExprNewLE( $1 ), $3 ); }
            | Expression GE    Expression  { $$ = hb_compExprSetOperand( hb_compExprNewGE( $1 ), $3 ); }
            | Expression NE1   Expression  { $$ = hb_compExprSetOperand( hb_compExprNewNE( $1 ), $3 ); }
            | Expression NE2   Expression  { $$ = hb_compExprSetOperand( hb_compExprNewNE( $1 ), $3 ); }
            | Expression '$'   Expression  { $$ = hb_compExprSetOperand( hb_compExprNewIN( $1 ), $3 ); }
            | Expression '='   Expression  { $$ = hb_compExprSetOperand( hb_compExprNewEqual( $1 ), $3 ); }
            | Expression LIKE  Expression  { $$ = hb_compExprSetOperand( hb_compExprNewLike( $1 ), $3 ); }
            | Expression MATCH Expression  { $$ = hb_compExprSetOperand( hb_compExprNewMatch( $1 ), $3 ); }
            ;

ArrayIndex : IndexList ']'                   { $$ = $1; }
           ;

/* NOTE: $0 represents the expression before ArrayIndex
 *    Don't use ArrayIndex in other context than as an array index!
 */
IndexList  : '[' Expression               { $$ = hb_compExprNewArrayAt( $<asExpr>0, $2 ); }
           | IndexList ',' Expression     { $$ = hb_compExprNewArrayAt( $1, $3 ); }
           | IndexList ']' '[' Expression { $$ = hb_compExprNewArrayAt( $1, $4 ); }
           ;

_Get_      : GET { pBaseArrayName = NULL; pGetVarArray = NULL; pGetArgList = NULL; pGetFunction = NULL; }
           ;

Get        : _Get_ LValue ','
               { /* $4 */
                  $2 = hb_compExprListStripSingle( $2, NULL );
                  $2 = HB_EXPR_USE( $2, HB_EA_REDUCE );

                  switch( $2->ExprType )
                  {
                     case HB_ET_VARIABLE:
                     case HB_ET_ALIASVAR:
                     case HB_ET_SEND:
                     case HB_ET_WITHSEND:
                     {
                        BOOL bSetGet;

                        if( $2->ExprType == HB_ET_VARIABLE )
                        {
                           char *szName = $2->value.asSymbol.szName;

                           bSetGet = ( hb_compLocalGetPos( szName ) ||
                                       hb_compStaticGetPos( szName, hb_comp_functions.pLast ) ||
                                       hb_compVariableGetPos( hb_comp_pGlobals, szName ) ||
                                       ( hb_comp_bStartProc == FALSE && hb_compStaticGetPos( szName, hb_comp_functions.pFirst ) ) ||
                                       hb_compMemvarGetPos( szName, hb_comp_functions.pLast ) ||
                                       hb_compFieldGetPos( szName, hb_comp_functions.pLast ) );
                        }
                        else
                        {
                           bSetGet = TRUE;
                        }

                        if( bSetGet )
                        {
                           HB_EXPR_PTR pSetGetBlock, pGetVar = hb_compExprClone( $2 ), pIsNil, pIfList, pIIF;

                           pIsNil       = hb_compExprSetOperand( hb_compExprNewEQ( hb_compExprNewVar( hb_compExpr_IDs._1 ) ), hb_compExprNewNil() );

                           pIfList      = hb_compExprNewList( pIsNil );
                           pIfList      = hb_compExprAddListExpr( pIfList, pGetVar );
                           pIfList      = hb_compExprAddListExpr( pIfList, hb_compExprAssign( hb_compExprClone( pGetVar ), hb_compExprNewVar( hb_compExpr_IDs._1 ) ) );

                           pIIF         = hb_compExprNewIIF( pIfList );

                           pSetGetBlock = hb_compExprNewCodeBlock();
                           pSetGetBlock = hb_compExprCBVarAdd( pSetGetBlock, hb_compExpr_IDs._1, ' ' );
                           pSetGetBlock = hb_compExprAddListExpr( pSetGetBlock, pIIF );

                           pGetArgList  = hb_compExprNewArgList( pSetGetBlock );
                        }
                        else
                        {
                           pGetArgList = hb_compExprNewArgList( hb_compExprNewNil() );
                        }

                        break;
                     }

                     case HB_ET_MACRO:
                        pGetArgList = hb_compExprNewArgList( hb_compExprNewNil() );

                        break;

                     case HB_ET_ARRAYAT:
                     {
                        HB_EXPR_PTR pArrayVar, pSetGetBlock;

                        bTrancuateBaseArray = TRUE;

                        pGetVarArray = $2;
                        pGetFunction = hb_compExprNewFunName( hb_compExpr_IDs.__GETA );

                        pArrayVar = pGetVarArray->value.asList.pExprList;
                        while( pArrayVar->ExprType == HB_ET_ARRAYAT )
                        {
                           pArrayVar = pArrayVar->value.asList.pExprList;
                        }

                        if( pArrayVar->ExprType == HB_ET_MACRO )
                        {
                           if( pArrayVar->value.asMacro.pExprList )
                           {
                              pBaseArrayName = hb_compExprClone( pArrayVar->value.asMacro.pExprList );
                           }
                           else
                           {
                              if( pArrayVar->value.asMacro.cMacroOp )
                              {
                                 //printf( "MacroVar: '%s'\n", pArrayVar->value.asMacro.szMacro );
                                 pBaseArrayName = hb_compExprNewVar( pArrayVar->value.asMacro.szMacro );
                              }
                              else
                              {
                                 //printf( "MacroText: '%s'\n", pArray->value.asMacro.szMacro );
                                 pBaseArrayName = hb_compExprNewString( pArrayVar->value.asMacro.szMacro, strlen( pArrayVar->value.asMacro.szMacro ), FALSE );
                              }
                           }

                           pSetGetBlock = hb_compExprNewNil();
                        }
                        else
                        {
                           pSetGetBlock = hb_compExprAddListExpr( hb_compExprNewCodeBlock(), hb_compExprClone( pArrayVar ) );
                        }

                        pGetArgList = hb_compExprNewArgList( pSetGetBlock );

                        break;
                     }

                     default:
                        hb_compErrorLValue( $2 );
                  }
               }

             EmptyExpression
               { /* $6 */
                  HB_EXPR_PTR pVarName;

                  switch( $2->ExprType )
                  {
                     case HB_ET_VARIABLE:
                     case HB_ET_ALIASVAR:
                     case HB_ET_SEND:
                     case HB_ET_WITHSEND:
                        pVarName = hb_compExprClone( $5 );
                        break;

                     case HB_ET_MACRO:
                     {
                        if( $2->value.asMacro.cMacroOp == '&' )
                        {
                           pVarName = hb_compExprNewVar( $2->value.asMacro.szMacro );
                        }
                        else if( $2->value.asMacro.szMacro )
                        {
                           pVarName = hb_compExprClone( $2->value.asMacro.pExprList );
                        }
                        else
                        {
                           /*
                              Clipper allways error, but we can handle simple macros or macros with no declared symbols!!!
                              hb_compYYError( 'E', HB_COMP_ERR_GET_COMPLEX_MACRO, NULL, NULL );
                            */
                           pVarName = hb_compExprClone( $5 );
                        }
                        break;
                     }


                     default:
                     {
                        /* HB_ET_ARRAYAT */
                        if( pGetVarArray )
                        {
                           if( pBaseArrayName )
                           {
                              pVarName = pBaseArrayName;
                              pBaseArrayName = NULL;
                           }
                           else
                           {
                              pVarName = hb_compExprClone( $5 );
                           }

                           bTrancuateBaseArray = FALSE;
                           break;
                        }
                        else
                        {
                           pVarName = NULL;
                           hb_compErrorLValue( $2 );
                           return 0;
                        }
                     }
                  }

                  hb_compExprAddListExpr( pGetArgList, pVarName ); /* Var Name   */
               }

             ',' EmptyExpression
               { /* $9 */
                  hb_compExprAddListExpr( pGetArgList, $8 ); /* Picture    */
               }

             ',' EmptyExpression
               { /* $12 */
                  hb_compExprAddListExpr( pGetArgList, $11 ); /* ValidBlock */
               }

             ',' EmptyExpression
               { /* $15 */
                  hb_compExprAddListExpr( pGetArgList, $14 ); /* WhenBlock  */

                  if( pGetVarArray )
                  {
                    HB_EXPR_PTR pArrayVar, pIndex, pTmp;

                    // We need to scan the Array backwards and build a list of the Index Expressions.
                    pArrayVar = pGetVarArray->value.asList.pExprList;
                    pIndex    = hb_compExprClone( pGetVarArray->value.asList.pIndex );

                    while( pArrayVar->ExprType == HB_ET_ARRAYAT )
                    {
                       pTmp = hb_compExprClone( pArrayVar->value.asList.pIndex );
                       pTmp->pNext = pIndex;
                       pIndex = pTmp;

                       pArrayVar = pArrayVar->value.asList.pExprList;
                    }

                    pIndex = hb_compExprNewList( pIndex );

                    /* Array with Index Expressions as 6th parameter */
                    hb_compExprAddListExpr( pGetArgList, hb_compExprNewArray( pIndex ) );
                  }
               }

             GetAExt ')'
               { /* $17 */
                  if( pGetFunction == NULL )
                  {
                     pGetFunction = hb_compExprNewFunName( hb_compExpr_IDs.__GET );
                  }

                  if( pBaseArrayName )
                  {
                     hb_compExprDelete( pBaseArrayName );
                  }

                  hb_compExprDelete( $2 );
                  hb_compExprDelete( $5 );

                  $$ = hb_compExprNewFunCall( pGetFunction, pGetArgList );
               }
           ;

GetArgList : Argument                     { $$ = hb_compExprAddListExpr( pGetArgList, $1 ); }
           | GetArgList ',' Argument      { $$ = hb_compExprAddListExpr( pGetArgList, $3 ); }
           ;

GetAExt    : { /* Nothing*/ }
           | ',' GetArgList
           ;

CodeBlock  : '{' CBMARKER

               {
                  $<asExpr>$ = hb_compExprNewCodeBlock();

                  if( hb_comp_BlocksList == NULL )
                  {
                     hb_comp_BlocksList = (PBLOCKSLIST) hb_xgrab( sizeof( BLOCKSLIST ) );
                     hb_comp_BlocksList->pBlock = $<asExpr>$;
                     hb_comp_BlocksList->pOuter = NULL;
                  }
                  else
                  {
                     PBLOCKSLIST pBlocksList = (PBLOCKSLIST) hb_xgrab( sizeof( BLOCKSLIST ) );

                     pBlocksList->pBlock = $<asExpr>$;
                     pBlocksList->pOuter = hb_comp_BlocksList;

                     hb_comp_BlocksList = pBlocksList;
                  }
               }

              BlockParams CBMARKER BlockExpList '}'

              {
                  PBLOCKSLIST pDelete = hb_comp_BlocksList;

                  if( s_bBlockMacro )
                  {
                     if( pBlockSimple && pBlockSimple->ExprType == HB_ET_MACRO && pBlockSimple->value.asMacro.SubType == HB_ET_MACRO_VAR )
                     {
                        HB_EXPR_PTR pMacroVar, pBlockString;

                        pMacroVar    = hb_compExprNewVar( pBlockSimple->value.asMacro.szMacro );
                        pBlockString = hb_compExprNewString( "{||", 3, FALSE );
                        pBlockString = hb_compExprSetOperand( hb_compExprNewPlus( pBlockString ), pMacroVar );
                        pBlockString = hb_compExprSetOperand( hb_compExprNewPlus( pBlockString ), hb_compExprNewString( "}", 1, FALSE ) );
                        $<asExpr>$   = hb_compExprNewMacro( pBlockString, 0, NULL );
                        hb_compExprDelete( $<asExpr>3 );
                     }
                     else if( s_bBlockDeclared )
                     {
                        hb_compYYError( 'E', HB_COMP_ERR_BLOCK, NULL, NULL );
                        $<asExpr>$ = $<asExpr>3;
                     }
                     else
                     {
                        char *szLastBlock = hb_comp_SLX_LastBlock( FALSE );
                        $<asExpr>$ = hb_compExprNewMacro( hb_compExprNewString( szLastBlock, strlen( szLastBlock ), FALSE ), 0, NULL );
                        hb_compExprDelete( $<asExpr>3 );
                     }
                  }
                  else
                  {
                     $$ = $<asExpr>3;
                  }

                  hb_comp_BlocksList = hb_comp_BlocksList->pOuter;

                  hb_xfree( (void *) pDelete );

                  if( hb_comp_BlocksList == NULL )
                  {
                     hb_comp_SLX_LastBlock( TRUE ); s_bBlockMacro = FALSE; s_bBlockDeclared = FALSE;
                  }
               }
           ;

BlockParams : BlockVarList {
                             PHB_CBVAR pVar = (PHB_CBVAR) $1->value.asList.pIndex;

                             while( pVar->pNext )
                             {
                                pVar = pVar->pNext;
                             }

                             if( pVar->szName == NULL )
                             {
                                if( pVar == (PHB_CBVAR) $1->value.asList.pIndex )
                                {
                                   //{|| ...} not realy a nameless argument.
                                }
                                else
                                {
                                   hb_compYYError( 'E', HB_COMP_ERR_NAMELESS_PARAM, NULL, NULL );
                                   hb_compExprDelete( $1 );
                                   $$ = NULL;
                                }
                             }
                           }
            ;

CodeBlock2  : '<' BITOR { hb_compCodeBlockStart(); hb_comp_iVarScope = VS_PARAMETER; } ExtBlockParams BITOR Crlf
                 Source
              '>'
               {
                  $$ = hb_compCodeBlockEnd( TRUE );
               }
            ;

ExtBlockParams : /* empty list */
               | ParamList
                 {
                   while( hb_comp_LocalParams )
                   {
                      PLOCALPARAM pDelete = hb_comp_LocalParams;

                      hb_compVariableAdd( hb_comp_LocalParams->szName, hb_comp_LocalParams->cType );

                      hb_comp_LocalParams = hb_comp_LocalParams->pNext;
                      hb_xfree( (void *) pDelete );
                   }
                 }
               ;

/* NOTE: This uses $-2 then don't use BlockExpList in other context
 */
BlockExpList : Expression                  { pBlockSimple = $1;   $$ = hb_compExprAddListExpr( $<asExpr>-2, $1 ); }
             | BlockExpList ',' Expression { pBlockSimple = NULL; $$ = hb_compExprAddListExpr( $<asExpr>-2, $3 ); }
             ;

/* NOTE: This is really not needed however it allows the use of $-2 item
 * in BlockExpList to refer the same rule defined in Codeblock
 */

BlockVarList : IdentName AsType                   { hb_comp_iVarScope = VS_LOCAL; $$ = hb_compExprCBVarAdd( $<asExpr>0, $1,    hb_comp_cVarType ); hb_comp_cVarType = ' '; }
             |                                    { hb_comp_iVarScope = VS_LOCAL;
                                                    $$ = hb_compExprCBVarAdd( $<asExpr>0, NULL , hb_comp_cVarType );
                                                    hb_comp_cVarType = ' ';
                                                  }
             | BlockVarList ',' IdentName AsType  { hb_comp_iVarScope = VS_LOCAL; $$ = hb_compExprCBVarAdd( $1, $3,    hb_comp_cVarType ); hb_comp_cVarType = ' '; }
             | BlockVarList ','                   { hb_comp_iVarScope = VS_LOCAL; $$ = hb_compExprCBVarAdd( $1, NULL,  hb_comp_cVarType ); hb_comp_cVarType = ' '; }
             ;

/* There is a conflict between the use of IF( Expr1, Expr2, Expr3 )
 * and parenthesized expression ( Expr1, Expr2, Expr3 )
 * To solve this conflict we have to split the definitions into more
 * atomic ones.
 *   Also the generation of pcodes have to be delayed and moved to the
 * end of whole parenthesized expression.
 */
PareExpList1: ExpList1 ')'        { $$ = $1; }
            ;

PareExpList2: ExpList2 ')'        { $$ = $1; }
            ;

PareExpList3: ExpList3 ')'        { $$ = $1; }
            ;

PareExpListN: ExpList ')'         { $$ = $1; }
           ;

PareExpList : PareExpList1        { $$ = $1; }
            | PareExpList2        { $$ = $1; }
            | PareExpList3        { $$ = $1; }
            | PareExpListN        { $$ = $1; }
            ;

PareExpListAlias : PareExpList ALIASOP     { $$ = $1; }
;

ExpList1   : '(' Argument    { $$ = hb_compExprNewList( $2 ); }
;

ExpList2   : ExpList1 ',' Argument    { $$ = hb_compExprAddListExpr( $1, $3 ); }
;

ExpList3   : ExpList2 ',' Argument    { $$ = hb_compExprAddListExpr( $1, $3 ); }
;

ExpList    : ExpList3 ',' Argument { $$ = hb_compExprAddListExpr( $1, $3 ); }
           | ExpList  ',' Argument { $$ = hb_compExprAddListExpr( $1, $3 ); }
           ;

IIFInline  : IIF PareExpList3          { $$ = hb_compExprNewIIF( $2 ); }
           ;

VarDefs    : LOCAL { hb_comp_iVarScope =  VS_LOCAL; hb_compLinePush(); } VarList Crlf { hb_comp_cVarType = ' '; }
           | STATIC { hb_comp_iVarScope = VS_STATIC; hb_compLinePush(); } VarList Crlf { hb_comp_cVarType = ' '; }
           | GLOBAL { hb_comp_iVarScope = VS_GLOBAL; hb_compLinePush(); } VarList Crlf { hb_comp_cVarType = ' '; }
           | EXTERNGLOBAL { hb_comp_iVarScope = VS_EXTERNGLOBAL; hb_compLinePush(); } VarList Crlf { hb_comp_cVarType = ' '; }
           ;

VarList    : VarDef                                  { $$ = 1; }
           | VarList ',' VarDef                      { $$++; }
           ;

ExtVarList : ExtVarDef                               { $$ = 1; }
           | ExtVarList ',' ExtVarDef                { $$++; }
           ;

/* NOTE: if STATIC or LOCAL variables are declared and initialized then we can
 * assign a value immediately - however for PRIVATE and PUBLIC variables
 * initialization have to be delayed because we have to create these variables
 * first.
 */
ExtVarDef  : VarDef
           | MacroVar AsType
               { hb_compRTVariableAdd( hb_compExprNewRTVar( NULL, $1 ), FALSE ); }
           | MacroVar AsType INASSIGN Expression
               { hb_compExprDelete( hb_compExprGenPush( $4 ) );
                 hb_compRTVariableAdd( hb_compExprNewRTVar( NULL, $1 ), TRUE );
               }
           | MacroVar DimList
               {
                  USHORT uCount = (USHORT) hb_compExprListLen( $2 );
                  hb_compExprDelete( hb_compExprGenPush( $2 ) );
                  hb_compGenPCode3( HB_P_ARRAYDIM, HB_LOBYTE( uCount ), HB_HIBYTE( uCount ), ( BOOL ) 1 );
                  hb_compRTVariableAdd( hb_compExprNewRTVar( NULL, $1 ), TRUE );
               }
           | MacroVar DimList AsArray
               {
                  USHORT uCount = (USHORT) hb_compExprListLen( $2 );
                  hb_compExprDelete( hb_compExprGenPush( $2 ) );
                  hb_compGenPCode3( HB_P_ARRAYDIM, HB_LOBYTE( uCount ), HB_HIBYTE( uCount ), ( BOOL ) 1 );
                  hb_compRTVariableAdd( hb_compExprNewRTVar( NULL, $1 ), TRUE );
               }
           ;

VarDef     : IdentName AsType { hb_compVariableAdd( $1, hb_comp_cVarType ); }
               {
                  if( hb_comp_iVarScope == VS_STATIC )
                  {
                     hb_compStaticDefStart();   /* switch to statics pcode buffer */
                     hb_compStaticDefEnd();
                     hb_compGenStaticName( $1 );
                  }
                  else if( hb_comp_iVarScope == VS_GLOBAL || hb_comp_iVarScope == VS_EXTERNGLOBAL )
                  {
                     /* hb_comp_pGlobals can be NULL after a "Misplaced GLOBAL"
                      * error in hb_compVariableAdd() call above.
                      * hb_compGenGlobalName() does not expect such situation */
                     if( hb_comp_pGlobals )
                     {
                        hb_compGlobalsDefStart();   /* switch to globals pcode buffer */
                        hb_compGlobalsDefEnd();
                        hb_compGenGlobalName( $1 );
                     }
                  }
                  else if( hb_comp_iVarScope == VS_PUBLIC || hb_comp_iVarScope == VS_PRIVATE )
                  {
                     hb_compRTVariableAdd( hb_compExprNewRTVar( $1, NULL ), FALSE );
                  }
               }

           | IdentName AsType { $<iNumber>$ = hb_comp_iVarScope;
                                hb_compVariableAdd( $1, hb_comp_cVarType );
                              }
             INASSIGN {hb_comp_cVarType = ' ';} Expression
               {
                  hb_comp_cCastType = hb_comp_cVarType;
                  hb_comp_cVarType = ' ';

                  hb_comp_iVarScope = $<iNumber>3;

                  if( hb_comp_iVarScope == VS_STATIC )
                  {
                     hb_compStaticDefStart();   /* switch to statics pcode buffer */
                     hb_compExprDelete( hb_compExprGenStatement( hb_compExprAssignStatic( hb_compExprNewVar( $1 ), $6 ) ) );
                     hb_compStaticDefEnd();
                     hb_compGenStaticName( $1 );
                  }
                  else if( hb_comp_iVarScope == VS_GLOBAL )
                  {
                     hb_compGlobalsDefStart();   /* switch to globals pcode buffer */
                     hb_compExprDelete( hb_compExprGenStatement( hb_compExprAssignStatic( hb_compExprNewVar( $1 ), $6 ) ) );
                     hb_compGlobalsDefEnd();
                     hb_compGenGlobalName( $1 );
                  }
                  else if( hb_comp_iVarScope == VS_EXTERNGLOBAL )
                  {
                     hb_compYYError( 'E', HB_COMP_ERR_EXTERNGLOBAL_ASSIGN, $1, NULL );
                  }
                  else if( hb_comp_iVarScope == VS_PUBLIC || hb_comp_iVarScope == VS_PRIVATE )
                  {
                     hb_compExprDelete( hb_compExprGenPush( $6 ) );
                     hb_compRTVariableAdd( hb_compExprNewRTVar( $1, NULL ), TRUE );
                  }
                  else
                  {
                     hb_compExprDelete( hb_compExprGenStatement( hb_compExprAssign( hb_compExprNewVar( $1 ), $6 ) ) );
                  }
                  hb_comp_iVarScope = $<iNumber>3;
               }

           | IdentName DimList          { hb_compVariableDim( $1, $2 ); }
           | IdentName DimList AsArray  { hb_compVariableDim( $1, $2 ); }
           ;

/* NOTE: DimList and DimIndex is the same as ArrayIndex and IndexList
 *       however we are using quite different actions here
 */
DimList    : DimIndex ']'                   { $$ = $1; }
           ;

DimIndex   : '[' Expression               { $$ = hb_compExprNewArgList( $2 ); }
           | DimIndex ',' Expression      { $$ = hb_compExprAddListExpr( $1, $3 ); }
           | DimIndex ']' '[' Expression  { $$ = hb_compExprAddListExpr( $1, $4 ); }
           ;


FieldsDef  : FIELD { hb_comp_iVarScope = VS_FIELD; } FieldList Crlf { hb_comp_cVarType = ' '; }
           ;

FieldList  : IdentName AsType               { $$=hb_compFieldsCount(); hb_compVariableAdd( $1, hb_comp_cVarType ); }
           | FieldList ',' IdentName AsType { hb_compVariableAdd( $3, hb_comp_cVarType ); }
           | FieldList IN IdentName { hb_compFieldSetAlias( $3, $<iNumber>1 ); }
           ;

MemvarDef  : MEMVAR { hb_comp_iVarScope = VS_MEMVAR; } MemvarList Crlf { hb_comp_cVarType = ' '; }
           ;

MemvarList : IdentName AsType                     { hb_compVariableAdd( $1, hb_comp_cVarType ); }
           | MemvarList ',' IdentName AsType      { hb_compVariableAdd( $3, hb_comp_cVarType ); }
           ;

Declaration: DECLARE IdentName '(' { hb_compDeclaredAdd( $2 ); hb_comp_szDeclaredFun = $2; } DecList ')' AsType Crlf
             {
               if( hb_comp_pLastDeclared )
               {
                 hb_comp_pLastDeclared->cType = hb_comp_cVarType;

                 if ( toupper( hb_comp_cVarType ) == 'S' )
                 {
                   hb_comp_pLastDeclared->Extended.pClass = hb_compClassFind( hb_comp_szFromClass );
                   if( ! hb_comp_pLastDeclared->Extended.pClass )
                   {
                     hb_compGenWarning( hb_comp_szWarnings, 'W', HB_COMP_WARN_CLASS_NOT_FOUND, hb_comp_szFromClass, hb_comp_pLastDeclared->szName );
                     hb_comp_pLastDeclared->cType = ( isupper(  ( BYTE ) hb_comp_cVarType ) ? 'O' : 'o' );
                   }

                   /* Resetting */
                   hb_comp_szFromClass = NULL;
                 }
               }

               hb_comp_szDeclaredFun = NULL;
               hb_comp_cVarType = ' ';
               hb_comp_iVarScope = VS_NONE;
             }
           | DECLARE IdentName { hb_comp_pLastClass = hb_compClassAdd( $2 ); } ClassInfo Crlf { hb_comp_iVarScope = VS_NONE; }
           | DECLARE_CLASS IdentName Crlf { hb_comp_pLastClass = hb_compClassAdd( $2 ); hb_comp_iVarScope = VS_NONE; }
           | DECLARE_MEMBER DecMethod Crlf { hb_comp_iVarScope = VS_NONE; hb_compLinePushIfInside(); }
           | DECLARE_MEMBER '{' AsType { hb_comp_cDataListType = hb_comp_cVarType; } DecDataList '}' Crlf { hb_comp_cDataListType = 0; hb_comp_iVarScope = VS_NONE; hb_compLinePushIfInside(); }
           ;

DecDataList: DecData
           | DecDataList ',' DecData
           ;

ClassInfo  : DecMethod
           | ClassInfo DecMethod
           | DecData
           | ClassInfo DecData
           ;

DecMethod  : IdentName '(' { hb_comp_pLastMethod = hb_compMethodAdd( hb_comp_pLastClass, $1, FALSE ); } DecList ')' AsType
             {
               if( hb_comp_pLastMethod )
               {
                 hb_comp_pLastMethod->cType = hb_comp_cVarType;
                 if ( toupper( hb_comp_cVarType ) == 'S' )
                 {
                   hb_comp_pLastMethod->Extended.pClass = hb_compClassFind( hb_comp_szFromClass );
                   if( ! hb_comp_pLastMethod->Extended.pClass )
                   {
                     hb_compGenWarning( hb_comp_szWarnings, 'W', HB_COMP_WARN_CLASS_NOT_FOUND, hb_comp_szFromClass, hb_comp_pLastMethod->szName );
                     hb_comp_pLastMethod->cType = ( isupper( ( BYTE ) hb_comp_cVarType ) ? 'O' : 'o' );
                   }

                   hb_comp_szFromClass = NULL;
                 }
               }
               hb_comp_pLastMethod = NULL;
               hb_comp_cVarType = ' ';
             }
           ;

DecData    : IdentName { hb_comp_pLastMethod = hb_compMethodAdd( hb_comp_pLastClass, $1, FALSE ); } AsType
             {
               if( hb_comp_pLastMethod )
               {
                 PCOMCLASS pClass;
                 char * szSetData = ( char * ) hb_xgrab( strlen( $1 ) + 2 );

                 /* List Type overrides if exists. */
                 if( hb_comp_cDataListType )
                 {
                    hb_comp_cVarType = hb_comp_cDataListType;
                 }

                 hb_comp_pLastMethod->cType = hb_comp_cVarType;

                 if ( toupper( hb_comp_cVarType ) == 'S' )
                 {
                   pClass = hb_compClassFind( hb_comp_szFromClass );
                   hb_comp_pLastMethod->Extended.pClass = pClass;
                   if( ! hb_comp_pLastMethod->Extended.pClass )
                   {
                     hb_compGenWarning( hb_comp_szWarnings, 'W', HB_COMP_WARN_CLASS_NOT_FOUND, hb_comp_szFromClass, hb_comp_pLastMethod->szName );
                     hb_comp_pLastMethod->cType = ( isupper( ( BYTE ) hb_comp_cVarType ) ? 'O' :'o' );
                   }
                 }
                 else
                 {
                   pClass = NULL;
                 }

                 hb_snprintf( szSetData, strlen( $1 ) + 2, "_%s", $1 );

                 hb_comp_pLastMethod = hb_compMethodAdd( hb_comp_pLastClass, szSetData, TRUE );
                 hb_comp_pLastMethod->cType = hb_comp_cVarType;
                 hb_comp_pLastMethod->iParamCount = 1;

                 hb_comp_pLastMethod->cParamTypes = ( BYTE * ) hb_xgrab( 1 );
                 hb_comp_pLastMethod->cParamTypes[0] = hb_comp_cVarType;

                 hb_comp_pLastMethod->pParamClasses = ( PCOMCLASS * ) hb_xgrab( sizeof( COMCLASS ) );
                 hb_comp_pLastMethod->pParamClasses[0] = pClass;

                 if ( toupper( hb_comp_cVarType ) == 'S' )
                 {
                   hb_comp_pLastMethod->Extended.pClass = pClass;
                   hb_comp_szFromClass = NULL;
                 }
                 // hb_xfree( szSetData );
               }

               hb_comp_pLastMethod = NULL;
               hb_comp_cVarType = ' ';
             }
           ;

DecList    : /* Nothing */ {}
           | FormalList
           | OptList
           | FormalList ',' OptList
           ;

FormalList : IdentName AsType                                  { hb_compDeclaredParameterAdd( $1, hb_comp_cVarType ); }
           | '@' IdentName AsType                              { hb_compDeclaredParameterAdd( $2, hb_comp_cVarType + VT_OFFSET_BYREF ); }
           | '@' IdentName '(' DummyArgList ')'                { hb_compDeclaredParameterAdd( $2, 'F' ); }
           | FormalList ',' IdentName AsType                   { hb_compDeclaredParameterAdd( $3, hb_comp_cVarType ); }
           | FormalList ',' '@' IdentName AsType               { hb_compDeclaredParameterAdd( $4, hb_comp_cVarType + VT_OFFSET_BYREF ); }
           | FormalList ',' '@' IdentName '(' DummyArgList ')' { hb_compDeclaredParameterAdd( $4, 'F' ); }
           ;

OptList    : OPTIONAL IdentName AsType                               { hb_compDeclaredParameterAdd( $2, hb_comp_cVarType + VT_OFFSET_OPTIONAL ); }
           | OPTIONAL '@' IdentName AsType                           { hb_compDeclaredParameterAdd( $3, hb_comp_cVarType + VT_OFFSET_OPTIONAL + VT_OFFSET_BYREF ); }
           | OPTIONAL '@' IdentName '(' DummyArgList ')'             { hb_compDeclaredParameterAdd( $3, hb_comp_cVarType + VT_OFFSET_OPTIONAL + VT_OFFSET_BYREF ); }
           | OptList ',' OPTIONAL IdentName AsType                   { hb_compDeclaredParameterAdd( $4, hb_comp_cVarType + VT_OFFSET_OPTIONAL ); }
           | OptList ',' OPTIONAL '@' IdentName AsType               { hb_compDeclaredParameterAdd( $5, hb_comp_cVarType + VT_OFFSET_OPTIONAL + VT_OFFSET_BYREF ); }
           | OptList ',' OPTIONAL '@' IdentName '(' DummyArgList ')' { hb_compDeclaredParameterAdd( $5, hb_comp_cVarType + VT_OFFSET_OPTIONAL + VT_OFFSET_BYREF ); }
           ;

EnumDef     : ENUM IdentName { hb_compEnumAdd( $2 ); } INASSIGN EnumMembers
            ;

EnumMembers : IdentName { hb_compEnumMemberAdd( $1 ); }
            | EnumMembers ',' IdentName { hb_compEnumMemberAdd( $3 ); }
            ;

ExecFlow   : IfEndif
           | DoCase
           | Switch
           | DoWhile
           | ForNext
           | ForEach
           | BeginSeq
           | Try
           ;

IfEndif    : IfBegin EndIf                    { hb_compGenJumpHere( $1 ); s_iControlLevel--; }
           | IfBegin IfElse EndIf             { hb_compGenJumpHere( $1 ); s_iControlLevel--; }
           | IfBegin IfElseIf EndIf           { hb_compGenJumpHere( $1 ); hb_compElseIfFix( $2 ); s_iControlLevel--; }
           | IfBegin IfElseIf IfElse EndIf    { hb_compGenJumpHere( $1 ); hb_compElseIfFix( $2 ); s_iControlLevel--; }
           ;

EmptyStats : /* empty */           { $<lNumber>$ = 0; }
           | Statements       { $<lNumber>$ = $<lNumber>1; }
           ;

IfBegin    : IF Expression {
                              ++hb_comp_wIfCounter; hb_compLinePush();

                              if( s_iControlLevel++ == 0 )
                              {
                                 s_iLastControlLine = hb_comp_iLine ;
                              }
                           }
             Crlf
                           {
                              hb_compExprDelete( hb_compExprGenPush( $2 ) ); $<iNumber>$ = (int) hb_compGenJumpFalse( 0 );
                           }
             EmptyStats
                           { $$ = (int) hb_compGenJump( 0 ); hb_compGenJumpHere( $<iNumber>5 ); }
           ;

IfElse     : ELSE Crlf { hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE; }
                EmptyStats
           ;

IfElseIf   : ELSEIF { hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE; hb_compLinePush(); } Expression Crlf
                { hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  hb_compExprDelete( hb_compExprGenPush( $3 ) );
                  $<iNumber>$ = (int) hb_compGenJumpFalse( 0 );
                }
                EmptyStats
                { $$ = hb_compElseIfGen( NULL, hb_compGenJump( 0 ) );
                  hb_compGenJumpHere( $<iNumber>5 );
                }

           | IfElseIf ELSEIF { hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE; hb_compLinePush(); } Expression Crlf
                { hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  hb_compExprDelete( hb_compExprGenPush( $4 ) );
                  $<iNumber>$ = (int) hb_compGenJumpFalse( 0 );
                }
                EmptyStats
                { $$ = hb_compElseIfGen( $1, hb_compGenJump( 0 ) );
                  hb_compGenJumpHere( $<iNumber>6 );
                }
           ;

EndIf      : ENDIF    { --hb_comp_wIfCounter; hb_comp_functions.pLast->bFlags &= ~ ( FUN_WITH_RETURN | FUN_BREAK_CODE ); }
           | END      { --hb_comp_wIfCounter; hb_comp_functions.pLast->bFlags &= ~ ( FUN_WITH_RETURN | FUN_BREAK_CODE ); }
           ;

DoCase     : DoCaseBegin
                Cases
             EndCase                  { hb_compElseIfFix( $2 ); }

           | DoCaseBegin
                Otherwise
             EndCase

           | DoCaseBegin
             EndCase

           | DoCaseBegin
                Cases
                Otherwise
             EndCase                   { hb_compElseIfFix( $2 ); }
           ;

EndCase    : ENDCASE
                     {
                        --hb_comp_wCaseCounter;
                        hb_comp_functions.pLast->bFlags &= ~ ( FUN_WITH_RETURN | FUN_BREAK_CODE );
                        s_iControlLevel--;
                     }
           | END
                     {
                        --hb_comp_wCaseCounter;
                        hb_comp_functions.pLast->bFlags &= ~ ( FUN_WITH_RETURN | FUN_BREAK_CODE );
                        s_iControlLevel--;
                     }
           ;

DoCaseStart : DOCASE {
                        ++hb_comp_wCaseCounter;

                        if( s_iControlLevel++ == 0 )
                        {
                           s_iLastControlLine = hb_comp_iLine;
                        }

                        hb_compLinePushIfDebugger();
                     }
              Crlf
            ;

DoCaseBegin : DoCaseStart            { }
            | DoCaseStart Statements {
                        if( $<lNumber>2 > 0 )
                        {
                           hb_compYYError( 'E', HB_COMP_ERR_MAYHEM_IN_CASE, NULL, NULL );
                        }
                     }
           ;

Cases      : CASE { hb_comp_bDontGenLineNum = FALSE; hb_compLinePush(); } Expression Crlf
               {
                  hb_compExprDelete( hb_compExprGenPush( $3 ) );
                  $<iNumber>$ = (int) hb_compGenJumpFalse( 0 );
               }
             EmptyStats
               {
                  hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  $$ = hb_compElseIfGen( 0, hb_compGenJump( 0 ) );
                  hb_compGenJumpHere( $<iNumber>5 );
               }

           | Cases CASE { hb_comp_bDontGenLineNum = FALSE; hb_compLinePush(); } Expression Crlf
               {
                  hb_compExprDelete( hb_compExprGenPush( $4 ) );
                  $<iNumber>$ = (int) hb_compGenJumpFalse( 0 );
               }
             EmptyStats
               {
                  hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  $$ = hb_compElseIfGen( $1, hb_compGenJump( 0 ) );
                  hb_compGenJumpHere( $<iNumber>6 );
               }
           ;

Otherwise  : OTHERWISE { hb_compLinePushIfDebugger(); } Crlf
               {
                  hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  hb_comp_bDontGenLineNum = FALSE;
               }

                EmptyStats

           | Otherwise OTHERWISE { hb_compYYError( 'E', HB_COMP_ERR_MAYHEM_IN_CASE, NULL, NULL ); } Crlf
                EmptyStats
           ;

Switch    : SwitchBegin
               SwitchCases
            EndSwitch
               {
                  hb_compLoopEnd();
                  //hb_compElseIfFix( $2 ); // No default BREAK in SWITCH.
                  hb_compGenPCode1( HB_P_POP );
               }

          | SwitchBegin
               SwitchCases
               Default
            EndSwitch
               {
                  hb_compLoopEnd();
                  //hb_compElseIfFix( $2 );
                  hb_compGenPCode1( HB_P_POP );
               }
           ;

EndSwitch  : EndSwitchID
               {
                  --hb_comp_wCaseCounter;

                  // NO EXIT statement precedes this END statement (must be the case where NO DEFAULT section exists).
                  if( hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter ] )
                  {
                     LONG lOffset;

                     /*
                        We must REMOVE the unconditional JUMP instruction at the end of the preceding
                        CASE statement [aiming to SKIP over the expected trailing CASE if no EXIT specified].
                      */
                     hb_comp_functions.pLast->lPCodePos -= 4;
                     hb_comp_functions.pLast->iJumps--;
                     hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter ] = 0;

                     /*
                        We must RE-correct the prior CASE Jump, since we removed 4 bytes.
                        $0 points to the previous rule (SwitchCases) which holds the offset to that last Jump.
                      */
                     switch( hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 - 1 ) ] )
                     {
                        case HB_P_JUMPFALSENEAR :
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) ] -= 4;
                          break;

                        case HB_P_JUMPFALSE :
                          lOffset = HB_PCODE_MKUSHORT( &( hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) ] ) ) - 4;
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) ]     = HB_LOBYTE( lOffset );
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 + 1 ) ] = HB_HIBYTE( lOffset );
                          break;

                        case HB_P_JUMPFALSEFAR :
                          lOffset = HB_PCODE_MKUINT24( &( hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) ] ) ) - 4;
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) ]     = HB_LOBYTE( lOffset );
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) + 1 ] = HB_HIBYTE( lOffset );
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) + 2 ] = HB_LOBYTE( HB_HIWORD( lOffset ) );
                          break;

                        default :
                          hb_compYYError( 'F', HB_COMP_ERR_JUMP_NOT_FOUND, NULL, NULL );
                     }
                  }

                  hb_comp_functions.pLast->bFlags &= ~ ( FUN_WITH_RETURN | FUN_BREAK_CODE );

                  s_iControlLevel--;
               }
           ;

EndSwitchID : ENDSWITCH
            | END
            ;

SwitchBegin : SWITCH Expression {  hb_comp_bDontGenLineNum = FALSE; hb_compLinePush();
                                   hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter++ ] = 0;
                                   hb_compExprDelete( hb_compExprGenPush( $2 ) );

                                   hb_compLoopStart( FALSE );

                                   if( s_iControlLevel++ == 0 )
                                   {
                                      s_iLastControlLine = hb_comp_iLine;
                                   }
                                }
                     Crlf
               WhiteSpace
            ;

WhiteSpace : /* Empty */
           | EmptyLines
           ;

EmptyLines : Crlf
           | Line
           | EmptyLines Crlf
           | EmptyLines Line
           ;

SwitchCases : CASE { hb_comp_bDontGenLineNum = FALSE; hb_compLinePush(); } Constant Crlf
               {
                  hb_compGenSwitchCase( ( LONG ) $3->value.asNum.lVal );
                  hb_compExprDelete( $3 );
                  $<iNumber>$ = (int) hb_compGenJumpFalse( 0 );
               }
             EmptyStats
               {
                  hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;

                  //$$ = hb_compElseIfGen( 0, hb_compGenJump( 0 ) ); // No default BREAK in SWITCH.

                  hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter - 1 ] = hb_compGenJump( 0 ); // Skip over NEXT HB_P_SWITCHCASE

                  hb_compGenJumpHere( $<iNumber>5 );

                  // Will be used as $0 in Default.
                  $$ = $<iNumber>5;
               }

           | SwitchCases CASE { hb_comp_bDontGenLineNum = FALSE; hb_compLinePush(); } Constant Crlf
               {
                  hb_compGenSwitchCase( ( LONG ) $4->value.asNum.lVal );
                  hb_compExprDelete( $4 );
                  $<iNumber>$ = (int) hb_compGenJumpFalse( 0 );

                  if( hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter - 1 ] )
                  {
                     hb_compGenJumpHere( hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter - 1 ] );
                  }
               }
             EmptyStats
               {
                  hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;

                  //$$ = hb_compElseIfGen( $1, hb_compGenJump( 0 ) ); // No default BREAK in SWITCH.

                  hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter - 1 ] = hb_compGenJump( 0 ); // Skip over NEXT HB_P_SWITCHCASE

                  hb_compGenJumpHere( $<iNumber>6 );

                  // Will be used as $0 in Default.
                  $$ = $<iNumber>6;
               }
           ;

Constant   : NUM_INTEGER               { $$ = hb_compExprNewLong( $1.iNumber ); }
           | '-' NUM_INTEGER %prec PRE { $$ = hb_compExprNewLong( - $2.iNumber ); }
           | NUM_LONG                  { $$ = hb_compExprNewLong( $1.lNumber ); }
           | '-' NUM_LONG    %prec PRE { $$ = hb_compExprNewLong( - $2.lNumber ); }
           | Constant '+' Constant {
                                     $<asExpr>1->value.asNum.lVal += $<asExpr>3->value.asNum.lVal;
                                     hb_compExprDelete( $<asExpr>3 );
                                     $$ = $1;
                                   }
           | Constant '-' Constant {
                                     $<asExpr>1->value.asNum.lVal -= $<asExpr>3->value.asNum.lVal;
                                     hb_compExprDelete( $<asExpr>3 );
                                     $$ = $1;
                                   }
           | Constant BITOR Constant {
                                     $<asExpr>1->value.asNum.lVal |= $<asExpr>3->value.asNum.lVal;
                                     hb_compExprDelete( $<asExpr>3 );
                                     $$ = $1;
                                   }
           | Constant BITAND Constant {
                                     $<asExpr>1->value.asNum.lVal &= $<asExpr>3->value.asNum.lVal;
                                     hb_compExprDelete( $<asExpr>3 );
                                     $$ = $1;
                                   }
           | '(' Constant ')'      { $$ = $<asExpr>2; }
           | LITERAL             {
                                    if( $1.length == 1 )
                                    {
                                       $$ = hb_compExprNewLong( (LONG) $1.string[0] );
                                    }
                                    else
                                    {
                                       hb_compYYError( 'E', HB_COMP_ERR_INVALID_CONSTANT, $1.string, NULL );
                                       $$ = hb_compExprNewLong( 0 );
                                    }
                                 }
           ;

Default    : DEFAULT
               {
                  // NO EXIT statement precedes this DEFAULT statement.
                  if( hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter - 1 ] )
                  {
                     LONG lOffset;

                     /*
                        We must REMOVE the unconditional JUMP instruction at the end of the preceding
                        CASE statement [aiming to SKIP over the expected trailing CASE if no EXIT specified].
                      */
                     hb_comp_functions.pLast->lPCodePos -= 4;
                     hb_comp_functions.pLast->iJumps--;
                     hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter - 1 ] = 0;

                     /*
                        We must RE-correct the prior CASE Jump, since we removed 4 bytes.
                        $0 points to the previous rule (SwitchCases) which holds the offset to that last Jump.
                      */
                     switch( hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 - 1 ) ] )
                     {
                        case HB_P_JUMPFALSENEAR :
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) ] -= 4;
                          break;

                        case HB_P_JUMPFALSE :
                          lOffset = HB_PCODE_MKUSHORT( &( hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) ] ) ) - 4;
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) ]     = HB_LOBYTE( lOffset );
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 + 1 ) ] = HB_HIBYTE( lOffset );
                          break;

                        case HB_P_JUMPFALSEFAR :
                          lOffset = HB_PCODE_MKUINT24( &( hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) ] ) ) - 4;
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) ]     = HB_LOBYTE( lOffset );
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) + 1 ] = HB_HIBYTE( lOffset );
                          hb_comp_functions.pLast->pCode[ ( ULONG ) ( $<iNumber>0 ) + 2 ] = HB_LOBYTE( HB_HIWORD( lOffset ) );
                          break;

                        default :
                          hb_compYYError( 'F', HB_COMP_ERR_JUMP_NOT_FOUND, NULL, NULL );
                     }
                  }

                  hb_comp_bDontGenLineNum = FALSE;
                  hb_compLinePush();
               }

               EmptyStats
               {
                  /*
                  // Correct last JUMP generated by SWITCHCASE to Skip the DEFAULT section.
                  if( hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter - 1 ] )
                  {
                     hb_compGenJumpHere( hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter - 1 ] );
                     hb_comp_alLastSwitchPos[ hb_comp_wCaseCounter - 1 ] = 0;
                  }

                  hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  */
               }
           ;

DoWhile    : WhileBegin Expression Crlf
               {
                  if( $2->ValType == HB_EV_LOGICAL && $2->value.asLogical )
                  {
                     hb_compExprDelete( $2 );
                     $<lNumber>$ = -1;
                  }
                  else
                  {
                     hb_compExprDelete( hb_compExprGenPush( $2 ) );
                     $<lNumber>$ = hb_compGenJumpFalse( 0 );
                  }
               }
             EmptyStats
               {
                  hb_compLoopHere();
                  hb_compGenJump( $1 - hb_comp_functions.pLast->lPCodePos );
               }
             EndWhile
               {
                  if( $<lNumber>4 != -1 )
                  {
                     hb_compGenJumpHere( $<lNumber>4 );
                  }
                  --hb_comp_wWhileCounter;
                  hb_compLoopEnd();
                  hb_comp_functions.pLast->bFlags &= ~ FUN_WITH_RETURN;
                }
           ;

WhileBegin : WHILE {
                      $$ = hb_comp_functions.pLast->lPCodePos;
                      hb_compLinePushIfInside();
                      ++hb_comp_wWhileCounter;
                      hb_compLoopStart( TRUE );

                      if( s_iControlLevel++ == 0 )
                      {
                         s_iLastControlLine = hb_comp_iLine;
                      }
                   }
           ;

EndWhile   : END   { hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE; s_iControlLevel--; }
           | ENDDO { hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE; s_iControlLevel--; }
           ;

ForNext    : FOR LValue ForAssign Expression          /* 1  2  3  4 */
               {
                  hb_compLinePush();
                  hb_compDebugStart();
                  ++hb_comp_wForCounter;              /* 5 */
                  $<asExpr>$ = hb_compExprGenStatement( hb_compExprAssign( hb_compExprClone( $2 ), $4 ) );
               }
             TO Expression StepExpr                   /* 6  7  8 */
               {
                  hb_compLoopStart( TRUE );
                  $<lNumber>$ = hb_comp_functions.pLast->lPCodePos;  /* 9 */
                  $2 = hb_compExprGenPush( $2 );              /* counter */
                  $7 = hb_compExprGenPush( $7 );              /* end */

                  if( $<asExpr>8 )
                  {
                     $<asExpr>8 = hb_compExprGenPush( $<asExpr>8 );   /* step */
                  }
               }
             Crlf                                     /* 10 */
               {
                  if( $<asExpr>8 )
                  {
                     hb_compGenPCode1( HB_P_FORTEST );
                  }
                  else
                  {
                     hb_compGenPCode1( HB_P_LESSEQUAL );
                  }

                  $<lNumber>$ = hb_compGenJumpFalse( 0 );   /* 11 */

                  if( s_iControlLevel++ == 0 )
                  {
                     s_iLastControlLine = hb_comp_iLine;
                  }
               }
             ForStatements                            /* 12 */
               {
                  short iStep, iLocal;

                  hb_compLoopHere();

                  if( $<asExpr>8 )
                  {
                     if( $<asExpr>8->ExprType == HB_ET_NUMERIC && $<asExpr>8->value.asNum.NumType == HB_ET_LONG &&
                         $<asExpr>8->value.asNum.lVal >= -32768 && $<asExpr>8->value.asNum.lVal <= 32767 )
                     {
                        iStep = ( short ) $<asExpr>8->value.asNum.lVal;
                     }
                     else
                     {
                        iStep = 0;
                     }
                  }
                  else
                  {
                     iStep = 1;
                  }

                  if( iStep && ( iLocal = (short) hb_compLocalGetPos( $<asExpr>2->value.asSymbol.szName ) ) != 0 && HB_LIM_INT8( iLocal ) )
                  {
                     if( iStep == 1 )
                     {
                        hb_compGenPCode2( HB_P_LOCALNEARINC, ( BYTE ) iLocal, ( BOOL ) 0 );
                     }
                     else if( iStep == -1  )
                     {
                        hb_compGenPCode2( HB_P_LOCALNEARDEC, ( BYTE ) iLocal, ( BOOL ) 0 );
                     }
                     else
                     {
                        hb_compGenPCode4( HB_P_LOCALNEARADDINT, ( BYTE ) iLocal, HB_LOBYTE( iStep ), HB_HIBYTE( iStep ), ( BOOL ) 0 );
                     }
                  }
                  else if( $<asExpr>8 )
                  {
                     $<asExpr>8 = hb_compExprGenStatement( hb_compExprSetOperand( hb_compExprNewPlusEq( hb_compExprClone( $2 ) ), $<asExpr>8 ) );
                  }
                  else
                  {
                     $<asExpr>8 = hb_compExprGenStatement( hb_compExprNewPreInc( hb_compExprClone( $2 ) ) );
                  }

                  hb_compGenJump( $<lNumber>9 - hb_comp_functions.pLast->lPCodePos );
                  hb_compGenJumpHere( $<lNumber>11 );

                  hb_compLoopEnd();

                  hb_compExprDelete( $2 );
                  hb_compExprDelete( $<asExpr>5 ); /* Deletes $5, hb_compExprClone( $2 ), $4 */
                  hb_compExprDelete( $7 );

                  if( $<asExpr>8 )
                  {
                     hb_compExprDelete( $<asExpr>8 ); /* Deletes hb_compExprClone( $2 ), and original $8 */
                  }

                  hb_comp_functions.pLast->bFlags &= ~ FUN_WITH_RETURN;
               }
           ;

ForAssign  : '='
           | INASSIGN
           ;

StepExpr   : /* default step expression */       { $<asExpr>$ = NULL; }
           | STEP Expression                     { $<asExpr>$ = hb_compExprReduce( $2 ); }
           ;

ForStatements : EmptyStats NEXT                  { hb_compLinePush();
                                                   if( hb_comp_wForCounter )
                                                      --hb_comp_wForCounter;
                                                   s_iControlLevel--; }
              | EmptyStats NEXT IdentName        { hb_compLinePush();
                                                   if( hb_comp_wForCounter )
                                                      --hb_comp_wForCounter;
                                                   s_iControlLevel--; }
              | EmptyStats END                   { hb_compLinePush();
                                                   if( hb_comp_wForCounter )
                                                      --hb_comp_wForCounter;
                                                   s_iControlLevel--; }
              | EmptyStats END IdentName         { hb_compLinePush();
                                                   if( hb_comp_wForCounter )
                                                      --hb_comp_wForCounter;
                                                   s_iControlLevel--; }
              ;

ForEach    : FOREACH IdentName  /* 1  2 */
               {  /* 3 */
                  hb_compLinePush();
                  hb_compDebugStart();
                  ++hb_comp_wForCounter;
                  //$2->ExprType = HB_ET_VARREF; hb_compExprGenPush( $2 );
                  hb_compExprDelete( hb_compExprGenPush( hb_compExprNewVarRef( $2 ) ) );
               }
             IN Expression /* 4 5 */
               { /* 6 */
                  hb_compExprDelete( hb_compExprGenPush( $5 ) );
                  hb_compGenPCode1( HB_P_FOREACH );
                  $<lNumber>$ = hb_comp_functions.pLast->lPCodePos;  /* 6 */
                  hb_compGenPCode1( HB_P_ENUMERATE );
                  hb_compLoopStart( TRUE );
               }
             Crlf                                     /* 7 */
               { /* 8 */
                  $<lNumber>$ = hb_compGenJumpFalse( 0 );   /* 8 */

                  if( s_iControlLevel++ == 0 )
                  {
                     s_iLastControlLine = hb_comp_iLine;
                  }
               }
             ForStatements                            /* 9 */
               {
                  hb_compLoopHere();
                  hb_compGenJump( $<lNumber>6 - hb_comp_functions.pLast->lPCodePos );
                  hb_compGenJumpHere( $<lNumber>8 );
                  hb_compLoopEnd();
                  hb_compGenPCode1( HB_P_ENDENUMERATE );
                  hb_comp_functions.pLast->bFlags &= ~ FUN_WITH_RETURN;
               }
           ;

WithObject : WITHOBJ Expression Crlf
               {
                  hb_compLinePush();
                  hb_compGenWithObject($2);
                  if( s_iControlLevel++ == 0 )
                  {
                     s_iLastControlLine = hb_comp_iLine;
                  }
               }
             EmptyStats
             END
               {
                  hb_compGenEndWithObject();
                  s_iControlLevel--;
               }
           ;

BeginSeq   : BEGINSEQ {
                         ++hb_comp_wSeqCounter;

                         $<lNumber>$ = hb_compSequenceBegin();

                         if( s_iControlLevel++ == 0 )
                         {
                            s_iLastControlLine = hb_comp_iLine;
                         }
                      }
                Crlf
                EmptyStats
                {
                  /* Set jump address for HB_P_SEQBEGIN opcode - this address
                   * will be used in BREAK code if there is no RECOVER clause
                   */
                   hb_compGenJumpHere( $<lNumber>2 );
                   $<lNumber>$ = hb_compSequenceEnd();
                }
                RecoverSeq
                {
                   /* Replace END address with RECOVER address in
                    * HB_P_SEQBEGIN opcode if there is RECOVER clause
                    */
                   if( $<lNumber>6 )
                      hb_compGenJumpThere( $<lNumber>2, $<lNumber>6 );
                   else if( hb_comp_wSeqCounter )
                     --hb_comp_wSeqCounter;
                }
             END
             {
                /* Fix END address
                 * There is no line number after HB_P_SEQEND in case no
                 * RECOVER clause is used
                 */
                hb_compGenJumpThere( $<lNumber>5, hb_comp_functions.pLast->lPCodePos );

                hb_compSequenceFinish( (ULONG)$<lNumber>2, (int)$<lNumber>4 );

                hb_comp_functions.pLast->bFlags &= ~ ( FUN_WITH_RETURN | FUN_BREAK_CODE );
                s_iControlLevel--;
             }
           ;

RecoverSeq : /* no recover */  { $<lNumber>$ = 0; hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE; }
           | RecoverEmpty Crlf EmptyStats
           | RecoverUsing Crlf EmptyStats
           ;

RecoverEmpty : RECOVER
               {
                  hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  $<lNumber>$ = hb_comp_functions.pLast->lPCodePos;
                  if( hb_comp_wSeqCounter )
                     --hb_comp_wSeqCounter;
                  hb_compLinePush();
                  hb_compGenPCode2( HB_P_SEQRECOVER, HB_P_POP, ( BOOL ) 0 );
               }
           ;

RecoverUsing : RECOVERUSING IdentName
               {
                  hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  $<lNumber>$ = hb_comp_functions.pLast->lPCodePos;
                  if( hb_comp_wSeqCounter )
                     --hb_comp_wSeqCounter;
                  hb_compLinePush();
                  hb_compGenPCode1( HB_P_SEQRECOVER );
                  hb_compGenPopVar( $2 );
               }
             ;

Try          : TRY           /* 1 */
               {             /* 2 */
                  ++hb_comp_wSeqCounter;
                  $<lNumber>$ = hb_compTryBegin();
                  if( s_iControlLevel++ == 0 )
                     s_iLastControlLine = hb_comp_iLine;
               }
               Crlf          /* 3 */
               EmptyStats    /* 4 */
               {             /* 5 */
                  /* Set jump address for HB_P_TRYBEGIN opcode - this address
                   * will be used in BREAK code if there is no RECOVER clause
                   */
                  hb_compGenJumpHere( $<lNumber>2 );
                  $<lNumber>$ = hb_compTryEnd();
                  $<lNumber>3 = hb_compLoopCount();
               }
               Catch         /* 6 */
               {             /* 7 */
                  /* Replace END address with RECOVER address in
                   * HB_P_TRYBEGIN opcode if there is RECOVER clause
                   */
                  if( $<lNumber>6 )
                     hb_compGenJumpThere( $<lNumber>2, $<lNumber>6 );
               }
               FinallyTry    /* 8 */
               {             /* 9 */
                  long lLoopCount = hb_compLoopCount();
                  hb_comp_functions.pLast->bFlags &= ~ ( FUN_WITH_RETURN | FUN_BREAK_CODE );
                  if( $<lNumber>8 )
                  {
                     if( $<lNumber>3 != lLoopCount )
                     {
                        /* FINALLY statement after CATCH with EXIT/LOOP statments */
                        hb_compYYError( 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "EXIT/LOOP", NULL );
                     }
                     --hb_comp_wFinallyCounter;
                     if( $<lNumber>6 == 0 )
                        hb_compGenJumpThere( $<lNumber>2, $<lNumber>8 );
                     /* replace END address with FINALLY address in
                        HB_P_ENDFINALLY opcode */
                     hb_compGenJumpThere( $<lNumber>5, $<lNumber>8 );

                     if( $<lNumber>6 )
                        hb_compGenJumpThere( $<lNumber>6 + 1, $<lNumber>8 );
                     else
                     {
                        /* Only if there is no CATCH clause */
                        --hb_comp_wSeqCounter;  /* CATCH is also considered as end of sequence */
                     }

                     hb_compGenPCode1( HB_P_ENDFINALLY );
                  }
                  else
                  {
                     //printf( "END to %li\n", hb_comp_functions.pLast->lPCodePos );
                     hb_compGenJumpThere( $<lNumber>5, hb_comp_functions.pLast->lPCodePos );

                     if( $<lNumber>6 == 0 )
                     {
                        /* Only if there is no CATCH clause */
                        --hb_comp_wSeqCounter;  /* CATCH is also considered as end of sequence */

                        hb_compYYError( 'E', HB_COMP_ERR_MISSING_HANDLER, NULL, NULL );
                     }
                  }

                  //hb_compTryFinish( $<lNumber>2, $<iNumber>4 );
                  hb_comp_functions.pLast->bFlags &= ~ FUN_WITH_RETURN;

                  s_iControlLevel--;
               }
               END
             ;


FinallyTry  : /* no finally */    { $<lNumber>$ = 0; }
            | Finally Crlf EmptyStats
            ;

Finally      : FINALLY
               {
                  hb_comp_functions.pLast->bFlags &= ~ ( FUN_WITH_RETURN | FUN_BREAK_CODE );
                  $<lNumber>$ = hb_comp_functions.pLast->lPCodePos;
                  ++hb_comp_wFinallyCounter;
                  hb_compGenPCode1( HB_P_FINALLY );
               }
             ;

Catch        : /* no recover */  { $<lNumber>$ = 0; }
             | CatchError Crlf EmptyStats
             ;

CatchError   : CATCH IdentName
               {
                  hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  $<lNumber>$ = hb_comp_functions.pLast->lPCodePos;
                  if ( hb_comp_wSeqCounter )
                     --hb_comp_wSeqCounter;
                  hb_compGenPCode4( HB_P_TRYRECOVER, 0, 0, 0, TRUE );
                  hb_compPrepareOptimize();
                  hb_compGenPopVar( $2 );
               }
             | CATCH
               {
                  hb_comp_functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  $<lNumber>$ = hb_comp_functions.pLast->lPCodePos;
                  if ( hb_comp_wSeqCounter )
                     --hb_comp_wSeqCounter;
                  hb_compGenPCode4( HB_P_TRYRECOVER, 0, 0, 0, TRUE );
                  hb_compPrepareOptimize();
                  hb_compGenPCode1( HB_P_POP );
               }
             ;

/* NOTE: In Clipper all variables used in DO .. WITH are passed by reference
 * however if they are part of an expression then they are passed by value
 * for example:
 * DO .. WITH ++variable
 * will pass the value of variable not a reference
 */
DoName     : IdentName       { $$ = hb_compExprNewFunName( $1 ); hb_compAutoOpenAdd( $1 ); }
           | MacroVar        { $$ = $1; }
           | MacroExpr       { $$ = $1; }
           ;

DoProc     : DO DoName
               {
                  $$ = hb_compExprNewFunCall( $2, NULL );
               }
           | DO DoName WITH DoArgList
               { $$ = hb_compExprNewFunCall( $2, $4 ); }
           | WHILE WITH DoArgList
               { hb_compAutoOpenAdd( hb_compExpr_IDs.WHILE_ ); $$ = hb_compExprNewFunCall( hb_compExprNewFunName( hb_compExpr_IDs.WHILE_ ), $3 ); }
           ;

DoArgList  : ','                       { $$ = hb_compExprAddListExpr( hb_compExprNewArgList( hb_compExprNewNil() ), hb_compExprNewNil() ); }
           | ',' DoArgument            { $$ = hb_compExprAddListExpr( hb_compExprNewArgList( hb_compExprNewNil() ), $2 ); }
           | DoArgument                { $$ = hb_compExprNewArgList( $1 ); }
           | DoArgList ','             { $$ = hb_compExprAddListExpr( $1, hb_compExprNewNil() ); }
           | DoArgList ',' DoArgument  { $$ = hb_compExprAddListExpr( $1, $3 ); }
           ;

DoArgument : IdentName                            {
                                                    if( hb_compFieldGetPos( $1, hb_comp_functions.pLast ) ||
                                                        ( hb_comp_bStartProc == FALSE && hb_compFieldGetPos( $1, hb_comp_functions.pFirst ) ) )
                                                    {
                                                      $$ = hb_compExprNewVar( $1 );
                                                    }
                                                    else
                                                    {
                                                      $$ = hb_compExprNewVarRef( $1 );
                                                    }
                                                  }
           | '@' IdentName                        { $$ = hb_compExprNewVarRef( $2 ); }
           | '@' IdentName '(' DummyArgList ')' { $$ = hb_compExprNewFunRef( $2 ); }
           | '@' NamespacePath IdentName '(' DummyArgList ')' { $$ = hb_compExprNewNamespaceFunRef( $2, $3 ); }
           | SimpleExpression                     { $$ = $1; }
           | PareExpList                          { $$ = $1; }
           ;

WithNamespace : WITH_NAMESPACE NamespaceName Crlf
                                 {
                                   PNAMESPACE pNamespace;

                                   if( hb_comp_UsedNamespaces.pFirst )
                                   {
                                      pNamespace = hb_compNamespaceFind( hb_comp_UsedNamespaces.pFirst, $2, NSTYPE_SPACE );

                                      if( pNamespace == NULL && $2[0] == '*' )
                                      {
                                         pNamespace = hb_compUsedNamespaceNew( "*", NSTYPE_SPACE );
                                         hb_compUsedNamespaceEnd();
                                      }

                                   }
                                   else
                                   {
                                      if( $2[0] == '*' )
                                      {
                                         pNamespace = hb_compUsedNamespaceNew( "*", NSTYPE_SPACE );
                                         hb_compUsedNamespaceEnd();
                                      }
                                      else
                                      {
                                         pNamespace = NULL;
                                      }
                                   }

                                   if( pNamespace == NULL || ( ( pNamespace->type & NSTYPE_SPACE ) != NSTYPE_SPACE ) )
                                   {
                                      hb_compYYError( 'E', HB_COMP_ERR_UNKNOWN_NAMESPACE, $2, NULL );
                                   }
                                   else
                                   {
                                      PNAMESPACE pClone;

                                      pClone = (PNAMESPACE) hb_xgrab( sizeof( _NAMESPACE ) );
                                      HB_MEMCPY( (void *) pClone, (void *) pNamespace, sizeof( _NAMESPACE ) );

                                      pClone->pOuter = hb_comp_UsedNamespaces.pCurrent;
                                      hb_comp_UsedNamespaces.pCurrent = pClone;
                                   }
                                 }
                Source
                END Crlf
                                 {
                                   PNAMESPACE pClone;

                                   pClone = hb_comp_UsedNamespaces.pCurrent;
                                   hb_comp_UsedNamespaces.pCurrent = hb_comp_UsedNamespaces.pCurrent->pOuter;
                                   hb_xfree( pClone );
                                 }
              ;

NamespaceName : IdentName { $$ = ( $1 == hb_compExpr_IDs.GLOBAL_ ? (char *) "*" : $1 ); }
              ;

Namespace  : NamespaceType IdentName Crlf
                                 {
                                   if( hb_comp_functions.pLast )
                                   {
                                       hb_comp_functions.pLast->bFlags |= FUN_SEALED;
                                   }

                                   if( ( ( $1 & NSTYPE_IMPLEMENTS ) == NSTYPE_IMPLEMENTS ) && hb_comp_Namespaces.pCurrent )
                                   {
                                      hb_compYYError( 'E', HB_COMP_ERR_IMPLEMENTS_IN_NAMESPACE, hb_comp_Namespaces.pCurrent->szName, NULL );
                                   }

                                   hb_compNamespaceNew( $2, $1 );
                                 }
             Source
             END Crlf
                                 {
                                   if( hb_comp_functions.pLast )
                                   {
                                       hb_comp_functions.pLast->bFlags |= FUN_SEALED;
                                   }

                                   hb_compNamespaceEnd();
                                 }
           ;



ExtNamespace : EXTERNAL_NAMESPACE IdentName Crlf
                                 {
                                   if( hb_comp_functions.pLast )
                                   {
                                       hb_comp_functions.pLast->bFlags |= FUN_SEALED;
                                   }

                                   if( hb_comp_Namespaces.pCurrent )
                                   {
                                      hb_compNamespaceNew( $2, NSTYPE_EXTERNAL | NSTYPE_SPACE );
                                      hb_compNamespaceEnd();
                                   }
                                   else
                                   {
                                      hb_compYYError( 'E', HB_COMP_ERR_UNMATCHED_NAMESPACE, $2, NULL );
                                   }
                                 }
             | EXTERNAL_NAMESPACE_MEMBER IdentName Crlf
                                 {
                                   if( hb_comp_functions.pLast )
                                   {
                                       hb_comp_functions.pLast->bFlags |= FUN_SEALED;
                                   }

                                   if( hb_comp_Namespaces.pCurrent )
                                   {
                                      hb_compNamespaceNew( $2, ( NSTYPE_EXTERNAL | NSTYPE_MEMBER ) );
                                      hb_comp_Namespaces.pLast->pOuter = hb_comp_Namespaces.pCurrent;

                                      hb_compSymbolAdd( $2, NULL, (void *) hb_comp_Namespaces.pCurrent, SYMF_NS_EXPLICITPTR );
                                   }
                                   else
                                   {
                                      hb_compYYError( 'E', HB_COMP_ERR_UNMATCHED_NAMESPACE, $2, NULL );
                                   }
                                 }
             ;


NamespaceType : NAMESPACE            { $$ = NSTYPE_SPACE; }
              | RUNTIME_NAMESPACE    { $$ = NSTYPE_RUNTIME; }
              | OPTIONAL_NAMESPACE   { $$ = NSTYPE_OPTIONAL; }
              | IMPLEMENTS_NAMESPACE { $$ = NSTYPE_IMPLEMENTS; }
              ;

NamespaceDefinition : DEFINE_NAMESPACE IdentName Crlf
                                 {
                                   hb_compUsedNamespaceNew( $2, NSTYPE_SPACE );
                                 }
                      NamespaceDefinitions
                      END Crlf
                                 {
                                   hb_compUsedNamespaceEnd();
                                 }
                    ;

NamespaceDefinitions : Crlf
                     | Line
                     | NamespaceDefinition
                     | NamespaceMemberDefinition
                     | NamespaceDefinitions
                       Crlf
                     | NamespaceDefinitions
                       Line
                     | NamespaceDefinitions
                       NamespaceDefinition
                     | NamespaceDefinitions
                       NamespaceMemberDefinition
                     ;

NamespaceMemberDefinition : DEFINE_NAMESPACEMEMBER IdentName Crlf
                                 {
                                   hb_compUsedNamespaceNew( $2, NSTYPE_MEMBER );
                                 }
                          ;


NamespaceUsing : USING_NAMESPACE UsedPath Crlf
                                               {
                                                 if( $2 )
                                                 {
                                                    ( (PNAMESPACE) $2 )->type |= NSTYPE_USED;
                                                 }
                                               }
               ;


UsedPath : IdentName
                    {
                       if( hb_comp_UsedNamespaces.pFirst )
                       {
                          $$ = (void *) hb_compNamespaceFind( hb_comp_UsedNamespaces.pFirst, $1, NSTYPE_SPACE );
                       }
                       else
                       {
                          $$ = NULL;
                       }

                       if( $$ == NULL )
                       {
                          hb_compYYError( 'E', HB_COMP_ERR_UNKNOWN_NAMESPACE, $1, NULL );
                          $$ = NULL;
                       }
                    }
         | UsedPath ',' IdentName
                                  {
                                     if( $1 )
                                     {
                                        if( ( (PNAMESPACE) $1 )->pNext == NULL )
                                        {
                                           hb_compYYError( 'E', HB_COMP_ERR_EMPTY_NAMESPACE, ( (PNAMESPACE) $1 )->szName, NULL );
                                        }

                                        $$ = (void *) hb_compNamespaceFindMember( ( (PNAMESPACE) $1 )->pNext, $3, NSTYPE_SPACE );

                                        if( $$ == NULL )
                                        {
                                           hb_compYYError( 'E', HB_COMP_ERR_NONMEMBER_NAMESPACE, $3, ( (PNAMESPACE) $1 )->szName );
                                        }
                                     }
                                  }
         ;


Crlf       : '\n'          { hb_comp_bError = FALSE; }
           | ';'           { hb_comp_bDontGenLineNum = TRUE; }
           ;

%%

/*
 ** ------------------------------------------------------------------------ **
 */

#if 0
int hb_compYACCMain( char * szName )
{
   /* Generate the starting procedure frame */
   if( hb_comp_bStartProc )
      hb_compFunctionAdd( hb_strupr( hb_strdup( szName ) ), HB_FS_PUBLIC, FUN_PROCEDURE );
   else
         /* Don't pass the name of module if the code for starting procedure
         * will be not generated. The name cannot be placed as first symbol
         * because this symbol can be used as function call or memvar's name.
         */
      hb_compFunctionAdd( hb_strupr( hb_strdup( "" ) ), HB_FS_PUBLIC, FUN_PROCEDURE );

   yyparse();

   /* fix all previous function returns offsets */
   hb_compFinalizeFunction();

   hb_compExternGen();       /* generates EXTERN symbols names */

   if( hb_comp_pInitFunc )
   {
      PCOMSYMBOL pSym;

      /* Fix the number of static variables */
      hb_comp_pInitFunc->pCode[ 3 ] = HB_LOBYTE( hb_comp_iStaticCnt );
      hb_comp_pInitFunc->pCode[ 4 ] = HB_HIBYTE( hb_comp_iStaticCnt );
      hb_comp_pInitFunc->iStaticsBase = hb_comp_iStaticCnt;

      pSym = hb_compSymbolAdd( hb_comp_pInitFunc->szName, NULL, NULL, SYMF_FUNCALL );
      pSym->cScope |= hb_comp_pInitFunc->cScope;

      hb_comp_functions.pLast->pNext = hb_comp_pInitFunc;
      hb_comp_functions.pLast = hb_comp_pInitFunc;

      hb_compGenPCode1( HB_P_ENDPROC );
      ++hb_comp_functions.iCount;
   }

   if( hb_comp_szAnnounce )
      hb_compAnnounce( hb_comp_szAnnounce );

   /* Close processed file (it is opened in hb_compInclude() function )
   */
   fclose( yyin );

   while( hb_comp_files.pLast )
   {
     PFILE pFile = hb_comp_files.pLast;
     if( pFile->pBuffer )
        hb_xfree( (void *) pFile->pBuffer );
     hb_xfree( (void *) pFile->szFileName );
     hb_comp_files.pLast = pFile->pPrev;
     hb_xfree( pFile );
   }
   hb_comp_files.pLast = NULL;

   return 0;
}
#endif

/* ------------------------------------------------------------------------ */

void yyerror( char * s )
{
   //printf( "Error: %i Line: %i Error at '%s'\n", hb_comp_bError, hb_comp_iLine, yytext );

   if( yytext[ 0 ] == '\n' )
   {
      if( yychar == 0 )
      {
         if( s_iControlLevel )
         {
            char LineAsString[32];

            hb_snprintf( LineAsString, sizeof( LineAsString ), "at line %i", s_iLastControlLine - 1 );
            hb_compYYError( 'E', HB_COMP_ERR_UNCLOSED_STRU, LineAsString, NULL );
         }
         else
         {
            hb_compYYError( 'E', HB_COMP_ERR_INCOMPLETE_STMT, NULL, NULL );
         }
      }
      else
      {
         hb_compYYError( 'E', HB_COMP_ERR_INCOMPLETE_STMT, NULL, NULL );
      }
   }
   else
   {
      if( hb_comp_wForCounter == 0 && ( yychar == NEXT || yychar == LOOP ) )
      {
         hb_compYYError( 'E', HB_COMP_ERR_NEXTFOR, NULL, NULL );
      }
      else if( yychar == EXIT && hb_comp_wForCounter == 0 && hb_comp_wSwitchCounter == 0 )
      {
         hb_compYYError( 'E', HB_COMP_ERR_UNMATCHED_EXIT, yytext, NULL );
      }
      else if( yychar == ENDDO && hb_comp_wWhileCounter == 0 )
      {
         hb_compYYError( 'E', HB_COMP_ERR_ENDDO, NULL, NULL );
      }
      else if( yychar == ENDCASE && hb_comp_wCaseCounter == 0 )
      {
         hb_compYYError( 'E', HB_COMP_ERR_ENDCASE, NULL, NULL );
      }
      else if( yychar == ENDIF && hb_comp_wIfCounter == 0 )
      {
         hb_compYYError( 'E', HB_COMP_ERR_ENDIF, NULL, NULL );
      }

      if( s_iControlLevel )
      {
         if( yychar == NEXT || yychar == ENDDO || yychar == ENDCASE )
         {
            if( hb_comp_wSeqCounter )
            {
               hb_compYYError( 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, yytext, NULL );
            }
            else
            {
               char LineAsString[32];
               hb_snprintf( LineAsString, sizeof( LineAsString ), "at line %i", s_iLastControlLine - 1 );
               hb_compYYError( 'E', HB_COMP_ERR_UNCLOSED_STRU, LineAsString, NULL );
            }
         }
         else
         {
            hb_compYYError( 'E', HB_COMP_ERR_YACC, s, yytext );
         }

         /*
          hb_comp_wForCounter
          hb_comp_wIfCounter
          hb_comp_wWhileCounter
          hb_comp_wCaseCounter
          hb_comp_wWithObjCounter
          hb_comp_wSwitchCounter
          */

          hb_comp_pLoops = NULL;

         //printf( "Token: %s (%i)\n", yytext, yychar );
      }
      else
      {
         hb_compYYError( 'E', HB_COMP_ERR_YACC, s, yytext );
      }
   }
}

#if 0
BOOL hb_compInclude( char * szFileName, HB_PATHNAMES * pSearch )
{
   PFILE pFile;

   yyin = hb_fopen( szFileName, "r" );
   if( ! yyin )
   {
      if( pSearch )
      {
         PHB_FNAME pFileName = hb_fsFNameSplit( szFileName );

         while( pSearch && !yyin )
         {
            char szFName[ HB_PATH_MAX ];    /* filename to parse */

            pFileName->szPath = pSearch->szPath;
            hb_fsFNameMerge( szFName, pFileName );
            yyin = hb_fopen( szFName, "r" );
            if( ! yyin )
            {
               pSearch = pSearch->pNext;
               if( ! pSearch )
                  return FALSE;
            }
         }

         hb_xfree( ( void * ) pFileName );
      }
      else
         return FALSE;
   }

   pFile = ( PFILE ) hb_xgrab( sizeof( _FILE ) );
   pFile->handle = yyin;
   pFile->pBuffer = hb_xgrab( HB_PP_BUFF_SIZE );
   pFile->iBuffer = pFile->lenBuffer = 10;
   pFile->szFileName = szFileName;
   pFile->iLine = 0;
   pFile->pPrev = hb_comp_files.pLast;

   hb_comp_files.pLast = pFile;

#ifdef __cplusplus
   yy_switch_to_buffer( ( YY_BUFFER_STATE ) ( hb_comp_buffer = ( char * ) yy_create_buffer( yyin, 8192 * 2 ) ) );
#else
   yy_switch_to_buffer( hb_comp_buffer = yy_create_buffer( yyin, 8192 * 2 ) );
#endif
   hb_comp_files.iFiles++;

   return TRUE;
}

int yywrap( void )   /* handles the EOF of the currently processed file */
{
   if( hb_comp_files.iFiles == 1 )
   {
      hb_xfree( hb_comp_files.pLast->pBuffer );
      hb_comp_files.pLast->pBuffer = NULL;
      return 1;      /* we have reached the main EOF */
   }

   return 0;
}
#endif

/* ************************************************************************* */

/*
 * This function stores the position in pcode buffer where the FOR/WHILE
 * loop starts. It will be used to fix any LOOP/EXIT statements
 */
static void hb_compLoopStart( BOOL fCanLoop )
{
   PTR_LOOPEXIT pLoop = ( PTR_LOOPEXIT ) hb_xgrab( sizeof( LOOPEXIT ) );

   if( hb_comp_pLoops )
   {
      PTR_LOOPEXIT pLast = hb_comp_pLoops;

      while( pLast->pNext )
         pLast = pLast->pNext;
      pLast->pNext = pLoop;
   }
   else
      hb_comp_pLoops = pLoop;

   pLoop->ulOffset        = hb_comp_functions.pLast->lPCodePos;  /* store the start position */
   pLoop->fCanLoop        = fCanLoop;   /* can we use LOOP inside */
   pLoop->iLine           = hb_comp_iLine;
   pLoop->wSeqCounter     = hb_comp_wSeqCounter;      /* store current SEQUENCE counter */
   pLoop->wWithObjCounter = hb_comp_wWithObjCounter;  /* store current WITH OBJECT counter */
   pLoop->wFinallyCounter = hb_comp_wFinallyCounter;  /* store current FINALLY counter */

   pLoop->pExitList       = NULL;
   pLoop->pLoopList       = NULL;
   pLoop->pNext           = NULL;
}

/*
 * return number of LOOP of EXIT statement in the top most structure
 */
static long hb_compLoopCount( void )
{
   PTR_LOOPEXIT pLastLoop, pLastExit, pLoop;
   long lCount = 0;

   pLastLoop = pLastExit = NULL;
   pLoop = hb_comp_pLoops;
   while( pLoop )
   {
      if( pLoop->fCanLoop )
         pLastLoop = pLoop;
      pLastExit = pLoop;
      pLoop = pLoop->pNext;
   }

   if( pLastLoop )
   {
      while( pLastLoop->pLoopList )
      {
         ++lCount;
         pLastLoop = pLastLoop->pLoopList;
      }
   }
   if( pLastExit )
   {
      while( pLastExit->pExitList )
      {
         ++lCount;
         pLastExit = pLastExit->pExitList;
      }
   }

   return lCount;
}

/*
 * Stores the position of LOOP statement to fix it later at the end of loop
 */
static void hb_compLoopLoop( void )
{
   PTR_LOOPEXIT pLast = NULL, pLoop;

   pLoop = hb_comp_pLoops;
   while( pLoop )
   {
      if( pLoop->fCanLoop )
         pLast = pLoop;
      pLoop = pLoop->pNext;
   }

   if( ! pLast )
   {
      hb_compYYError( 'E', HB_COMP_ERR_UNMATCHED_EXIT, "LOOP", NULL );
   }
   else
   {
      if( pLast->wSeqCounter != hb_comp_wSeqCounter )
      {
         /* Attempt to LOOP from BEGIN/END sequence
         * Current SEQUENCE counter is different then at the beginning of loop
         * Notice that LOOP is allowed in RECOVER code.
         */
         hb_compYYError( 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "LOOP", NULL );
      }
      else if( pLast->wFinallyCounter != hb_comp_wFinallyCounter )
      {
         /* Attempt to LOOP from FINALLY block of TRY/END sequence
          */
         hb_compYYError( 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "LOOP", NULL );
      }
      else
      {
         USHORT wWithObjCounter = pLast->wWithObjCounter;

         pLoop = ( PTR_LOOPEXIT ) hb_xgrab( sizeof( LOOPEXIT ) );
         pLoop->pLoopList = NULL;

         while( pLast->pLoopList )
         {
            pLast = pLast->pLoopList;
         }

         pLast->pLoopList = pLoop;

         while( wWithObjCounter < hb_comp_wWithObjCounter )
         {
            hb_compGenPCode1( HB_P_ENDWITHOBJECT );
            wWithObjCounter++;
         }

         pLoop->ulOffset = hb_comp_functions.pLast->lPCodePos;  /* store the position to fix */
         hb_compGenJump( 0 );
      }
   }
}

/*
 * Stores the position of EXIT statement to fix it later at the end of loop
 */
static void hb_compLoopExit( void )
{
   if( ! hb_comp_pLoops )
   {
      hb_compYYError( 'E', HB_COMP_ERR_UNMATCHED_EXIT, "EXIT", NULL );
   }
   else
   {
      PTR_LOOPEXIT pLast, pLoop;

      pLast = hb_comp_pLoops;
      while( pLast->pNext )
         pLast = pLast->pNext;

      if( pLast->wSeqCounter != hb_comp_wSeqCounter )
      {
         /* Attempt to EXIT from BEGIN/END sequence
         * Current SEQUENCE counter is different then at the beginning of loop
         * Notice that LOOP is allowed in RECOVER code.
         */
         hb_compYYError( 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "EXIT", NULL );
      }
      else if( pLast->wFinallyCounter != hb_comp_wFinallyCounter )
      {
         /* Attempt to EXIT from FINALLY block of TRY/END sequence
          */
         hb_compYYError( 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "EXIT", NULL );
      }
      else
      {
         USHORT wWithObjCounter = pLast->wWithObjCounter;

         pLoop = ( PTR_LOOPEXIT ) hb_xgrab( sizeof( LOOPEXIT ) );
         pLoop->pExitList = NULL;
         while( pLast->pExitList )
         pLast = pLast->pExitList;
         pLast->pExitList = pLoop;

         while( wWithObjCounter < hb_comp_wWithObjCounter )
         {
            hb_compGenPCode1( HB_P_ENDWITHOBJECT );
            wWithObjCounter++;
         }

         pLoop->ulOffset = hb_comp_functions.pLast->lPCodePos;  /* store the position to fix */
         hb_compGenJump( 0 );
      }
   }
}

/*
 * Fixes the LOOP statement
 */
static void hb_compLoopHere( void )
{
   PTR_LOOPEXIT pLoop = hb_comp_pLoops, pFree, pLast;

   if( pLoop )
   {
      while( pLoop->pNext )
      {
         pLoop = pLoop->pNext;
      }

      pLast = pLoop;
      pLoop = pLoop->pLoopList;

      while( pLoop )
      {
         hb_compGenJumpHere( pLoop->ulOffset + 1 );
         pFree = pLoop;
         pLoop = pLoop->pLoopList;
         hb_xfree( ( void * ) pFree );
      }

      pLast->pLoopList = NULL;
   }
}

/*
 * Fixes the EXIT statements and releases memory allocated for current loop
 */
static void hb_compLoopEnd( void )
{
   PTR_LOOPEXIT pExit, pLoop = hb_comp_pLoops, pLast = hb_comp_pLoops, pFree;

   if( pLoop )
   {
      while( pLoop->pNext )
      {
         pLast = pLoop;
         pLoop = pLoop->pNext;
      }

      pExit = pLoop->pExitList;
      while( pExit )
      {
         hb_compGenJumpHere( pExit->ulOffset + 1 );
         pFree = pExit;
         pExit = pExit->pExitList;
         hb_xfree( ( void * ) pFree );
      }

      pLast->pNext = NULL;
      if( pLoop == hb_comp_pLoops )
         hb_comp_pLoops = NULL;
      hb_xfree( ( void * ) pLoop );
   }
}

void hb_compReleaseLoops( void )
{
   PTR_LOOPEXIT pLoop, pFree;

   while( hb_comp_pLoops )
   {
      pLoop = hb_comp_pLoops;
      while( pLoop->pExitList )
      {
         pFree = pLoop->pExitList;
         pLoop->pExitList = pFree->pExitList;
         hb_xfree( ( void * ) pFree );
      }
      while( pLoop->pLoopList )
      {
         pFree = pLoop->pLoopList;
         pLoop->pLoopList = pFree->pLoopList;
         hb_xfree( ( void * ) pFree );
      }
      hb_comp_pLoops = pLoop->pNext;
      hb_xfree( ( void * ) pLoop );
   }
}

static void * hb_compElseIfGen( void * pFirst, HB_SIZE ulOffset )
{
   PELSEIF pElseIf = ( PELSEIF ) hb_xgrab( sizeof( _ELSEIF ) ), pLast;

   pElseIf->ulOffset = ulOffset;
   pElseIf->pNext = NULL;
   pElseIf->pPrevGroup = NULL;

   if( pFirst )
   {
      pLast = ( PELSEIF ) pFirst;

      while( pLast->pNext )
      {
         pLast = pLast->pNext;
      }

      pLast->pNext = pElseIf;
   }
   else
   {
      if( hb_comp_pElseIfs )
      {
         pElseIf->pPrevGroup = hb_comp_pElseIfs;
      }

      hb_comp_pElseIfs = pElseIf;

      pFirst = pElseIf;
   }

   return pFirst;
}

static void hb_compElseIfFix( void * pFixElseIfs )
{
   PELSEIF pFix = ( PELSEIF ) pFixElseIfs;

   while( pFix )
   {
      hb_compGenJumpHere( pFix->ulOffset );
      pFix = pFix->pNext;
   }
}

void hb_compReleaseElseIfs( void )
{
   PELSEIF pElseIf;
   PELSEIF pDel;

   while( hb_comp_pElseIfs )
   {
      pElseIf = hb_comp_pElseIfs;
      hb_comp_pElseIfs = pElseIf->pPrevGroup;

      while( pElseIf )
      {
         pDel = pElseIf;
         pElseIf = pElseIf->pNext;
         hb_xfree( pDel );
      }
   }
}

static void hb_compRTVariableAdd( HB_EXPR_PTR pVar, BOOL bPopInitValue )
{
   HB_RTVAR_PTR pRTvar = ( HB_RTVAR_PTR ) hb_xgrab( sizeof( HB_RTVAR ) );

   pRTvar->pVar = pVar;
   pRTvar->bPopValue = bPopInitValue;
   pRTvar->pNext = NULL;
   pRTvar->pPrev = NULL;

   if( hb_comp_rtvars )
   {
      HB_RTVAR_PTR pLast = hb_comp_rtvars;

      while( pLast->pNext )
      {
         pLast = pLast->pNext;
      }

      pLast->pNext = pRTvar;
      pRTvar->pPrev = pLast;
   }
   else
   {
      hb_comp_rtvars = pRTvar;
   }
}

static void hb_compRTVariableGen( char * szCreateFun )
{
   USHORT usCount = 0;
   HB_RTVAR_PTR pVar = hb_comp_rtvars;
   HB_RTVAR_PTR pDel;

   /* generate the function call frame */
   hb_compGenPushFunCall( szCreateFun, NULL );
   hb_compGenPushNil();

   /* push variable names to create */
   while( pVar->pNext )
   {
      hb_compExprGenPush( pVar->pVar );
      pVar = pVar->pNext;
      ++usCount;
   }

   hb_compExprGenPush( pVar->pVar );
   ++usCount;

   /* call function that will create either PUBLIC or PRIVATE variables */
   if( usCount > 255 )
   {
      hb_compGenPCode3( HB_P_DO, HB_LOBYTE( usCount ), HB_HIBYTE( usCount ), ( BOOL ) 1 );
   }
   else
   {
      hb_compGenPCode2( HB_P_DOSHORT, ( BYTE ) usCount, ( BOOL ) 1 );
   }

   /* pop initial values */
   while( pVar )
   {
      if( pVar->bPopValue )
      {
         hb_compExprDelete( hb_compExprGenPop( pVar->pVar ) );
      }
      else
      {
         hb_compExprDelete( pVar->pVar );
      }

      pDel = pVar;
      pVar = pVar->pPrev;

      hb_xfree( pDel );
   }

   hb_comp_rtvars = NULL;
}

static void hb_compVariableDim( char * szName, HB_EXPR_PTR pInitValue )
{
  if( hb_comp_iVarScope == VS_PUBLIC || hb_comp_iVarScope == VS_PRIVATE )
  {
     USHORT uCount = (USHORT) hb_compExprListLen( pInitValue );
     hb_compVariableAdd( szName, 'A' );
     hb_compExprDelete( hb_compExprGenPush( pInitValue ) );
     hb_compGenPCode3( HB_P_ARRAYDIM, HB_LOBYTE( uCount ), HB_HIBYTE( uCount ), ( BOOL ) 1 );
     hb_compRTVariableAdd( hb_compExprNewRTVar( szName, NULL ), TRUE );
  }
  else if( hb_comp_iVarScope == VS_STATIC )
  {
     USHORT uCount = (USHORT) hb_compExprListLen( pInitValue );
     HB_EXPR_PTR pVar = hb_compExprNewVar( szName );
     HB_EXPR_PTR pAssign;

     /* create a static variable */
     hb_compVariableAdd( szName, 'A' );
     hb_compStaticDefStart();   /* switch to statics pcode buffer */
     /* create an array */
     hb_compExprGenPush( pInitValue );
     hb_compGenPCode3( HB_P_ARRAYDIM, HB_LOBYTE( uCount ), HB_HIBYTE( uCount ), ( BOOL ) 1 );
     /* check if valid initializers were used but don't generate any code */
     pAssign = hb_compExprAssignStatic( pVar, pInitValue );
     /* now pop an array */
     hb_compExprGenPop( pVar );
     /* delete all used expressions */
     hb_compExprDelete( pAssign );
     hb_compStaticDefEnd();
     hb_compGenStaticName( szName );
  }
  else if( hb_comp_iVarScope == VS_GLOBAL )
  {
     USHORT uCount = (USHORT) hb_compExprListLen( pInitValue );
     HB_EXPR_PTR pVar = hb_compExprNewVar( szName );
     HB_EXPR_PTR pAssign;

     /* create a global variable */
     hb_compVariableAdd( szName, 'A' );
     hb_compGlobalsDefStart();   /* switch to globals pcode buffer */
     /* create an array */
     hb_compExprGenPush( pInitValue );
     hb_compGenPCode3( HB_P_ARRAYDIM, HB_LOBYTE( uCount ), HB_HIBYTE( uCount ), ( BOOL ) 1 );
     /* check if valid initializers were used but don't generate any code */
     pAssign = hb_compExprAssignStatic( pVar, pInitValue );
     /* now pop an array */
     hb_compExprGenPop( pVar );
     /* delete all used expressions */
     hb_compExprDelete( pAssign );
     hb_compGlobalsDefEnd();
     hb_compGenGlobalName( szName );
  }
  else if( hb_comp_iVarScope == VS_EXTERNGLOBAL )
  {
     hb_compYYError( 'E', HB_COMP_ERR_EXTERNGLOBAL_ASSIGN, szName, NULL );
  }
  else
  {
     USHORT uCount = (USHORT) hb_compExprListLen( pInitValue );

     hb_compVariableAdd( szName, 'A' );
     hb_compExprDelete( hb_compExprGenPush( pInitValue ) );
     hb_compGenPCode3( HB_P_ARRAYDIM, HB_LOBYTE( uCount ), HB_HIBYTE( uCount ), ( BOOL ) 1 );
     hb_compExprDelete( hb_compExprGenPop( hb_compExprNewVar( szName ) ) );
  }
}

void hb_compReleaseRTVars( void )
{
   HB_RTVAR_PTR pVar;

   while( hb_comp_rtvars )
   {
      pVar = hb_comp_rtvars;
      hb_compExprDelete( pVar->pVar );
      hb_comp_rtvars = pVar->pPrev;
      hb_xfree( pVar );
   }
}

static void hb_compYYError( char cPrefix, int iError, const char * szError1, const char * szError2 )
{
   hb_compGenError( hb_comp_szErrors, cPrefix, iError, szError1, szError2 );

   while( hb_comp_BlocksList )
   {
      PBLOCKSLIST pDelete = hb_comp_BlocksList;

      hb_comp_BlocksList = hb_comp_BlocksList->pOuter;
      hb_xfree( (void *) pDelete );
   }

   while( hb_comp_LocalParams )
   {
      PLOCALPARAM pDelete = hb_comp_LocalParams;

      hb_comp_LocalParams = hb_comp_LocalParams->pNext;
      hb_xfree( (void *) pDelete );
   }

   hb_compReleaseLoops();
}
