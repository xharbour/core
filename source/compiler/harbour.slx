/*
 * $Id: harbour.slx 9759 2012-10-15 14:02:59Z andijahja $
 */

/*
 * xHarbour Project source code:
 * Compiler SimpLex rules
 *
 * Copyright 2000 Ron Pinkas <ronpinkas@profit-master.com>
 * www - http://www.xharbour.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA (or visit the web site http://www.gnu.org/).
 *
 * As a special exception, the Harbour Project gives permission for
 * additional uses of the text contained in its release of Harbour.
 *
 * The exception is that, if you link the Harbour libraries with other
 * files to produce an executable, this does not by itself cause the
 * resulting executable to be covered by the GNU General Public License.
 * Your use of that executable is in no way restricted on account of
 * linking the Harbour library code into it.
 *
 * This exception does not however invalidate any other reasons why
 * the executable file might be covered by the GNU General Public License.
 *
 * This exception applies only to the code released by the Harbour
 * Project under the name Harbour.  If you copy code from other
 * Harbour Project or Free Software Foundation releases into a copy of
 * Harbour, as the General Public License permits, the exception does
 * not apply to the code that you add in this way.  To avoid misleading
 * anyone as to the status of such modified files, you must delete
 * this exception notice from them.
 *
 * If you write modifications of your own for Harbour, it is your choice
 * whether to permit this exception to apply to your modifications.
 * If you do not wish that, delete this exception notice.
 *
 */

//#define SHOW_LEX_TOKENS
//#define DEBUG_LEX

#include "hbexemem.h"
#define HB_INLINE_MAX 999

#ifdef DEBUG_LEX
   #undef DEBUG_INFO
      #define DEBUG_INFO(x) x
#endif

#undef LEX_ABBREVIATE
   #define LEX_ABBREVIATE 4

#define IS_OP( x ) (                    \
                      x == INASSIGN  || \
                      x == EQ        || \
                      x == BITSHIFTL || \
                      x == LE        || \
                      x == NE1       || \
                      x == GE        || \
                      x == BITSHIFTR || \
                      x == NE2       || \
                      x == INC       || \
                      x == PLUSEQ    || \
                      x == DEC       || \
                      x == MINUSEQ   || \
                      x == ALIASOP   || \
                      x == HASHOP    || \
                      x == MULTEQ    || \
                      x == POWER     || \
                      x == DIVEQ     || \
                      x == EXPEQ     || \
                      x == BITXOR    || \
                      x == MODEQ     || \
                      strchr( "+-*/^<>=#!", x ) || \
                      x == LIKE || x == MATCH || x == STEP || x == TO || x == IN \
                   )

#define IS_NUM( x ) (                     \
                      x == NUM_INTEGER || \
                      x == NUM_LONG    || \
                      x == NUM_DOUBLE     \
                    )

static int iWantsEOL, iWantsEXP, iWantsID, iWantsVAR;

static unsigned char iIdentifier = 0;
static char *sIdOnHold, *s_sLastBlock = NULL;

//static char *sTextFunction, *sTextReset;

char * hb_comp_SLX_LastBlock( BOOL bReset );

static int hb_comp_SLX_Str2Num( char* szNum, HB_LONG * lVal, double * dVal, int * iDec, int * iWidth, BOOL* pbError );
static int hb_comp_SLX_ElementToken( char* szToken, unsigned int iTokenLen );
static int hb_comp_SLX_InterceptAction( int iRet );
static int hb_comp_SLX_CustomAction( int x );

static void hb_compCheckIllegalChar( char * szName );

/* -----------------------------------------------------  Language Definitions. ---------------------------------------------------- */

/* Delimiters. */
ACCEPT_TOKEN_AND_DROP_DELIMITER_IF_ONE_OF_THESE( " \t" );

#define HB_CHK_BLOCK    LEX_CUSTOM_ACTION - 1

#define USE_CONDITIONAL_DELIMITERS
CONDITIONAL_DELIMITERS_ARE         {
                                     LEX_DELIMITER( '.'  ) AS_TOKEN( '.' ),
                                   };

#undef IF_ACCEPT_AS_DELIMITER
#undef IF_ACCEPT_AS_DELIMITER
   /* We know chr to only be '.', so ignoring chr! */
   #define IF_ACCEPT_AS_DELIMITER( chr ) BOOL bAccept = TRUE; \
                                         \
                                         if( iLen == 0 ) \
                                         { \
                                            bAccept = ! ( isdigit( szBuffer[0] ) || \
                                                          ( szBuffer[0] == '.' && szBuffer[1] == '.' ) \
                                                        ); \
                                         } \
                                         else \
                                         { \
                                            if( isdigit( sToken[0] ) ) \
                                            { \
                                              bAccept = FALSE; \
                                            } \
                                            else if( sToken[0] == '.' ) \
                                            { \
                                              bAccept = FALSE; \
                                            } \
                                            else \
                                            { \
                                              sToken[iLen] = '\0'; \
                                              bAccept = strchr( sToken, '&' ) == NULL; \
                                            } \
                                         } \
                                         \
                                         if( bAccept )

ACCEPT_TOKEN_AND_RETURN_DELIMITERS {
                                     LEX_DELIMITER( ','  ) AS_TOKEN( ',' ),
                                     LEX_DELIMITER( '('  ) AS_TOKEN( '(' ),
                                     LEX_DELIMITER( ')'  ) AS_TOKEN( ')' ),
                                     LEX_DELIMITER( '['  ) AS_TOKEN( '[' ),
                                     LEX_DELIMITER( ']'  ) AS_TOKEN( ']'      + DONT_REDUCE ),
                                     LEX_DELIMITER( '}'  ) AS_TOKEN( '}'      + DONT_REDUCE ),
                                     LEX_DELIMITER( ':'  ) AS_TOKEN( ':' ),
                                     LEX_DELIMITER( '='  ) AS_TOKEN( '=' ),
                                     LEX_DELIMITER( '#'  ) AS_TOKEN( NE1 ),
                                     LEX_DELIMITER( '@'  ) AS_TOKEN( '@' ),
                                     LEX_DELIMITER( '<'  ) AS_TOKEN( '<'      + DONT_REDUCE ),
                                     LEX_DELIMITER( '>'  ) AS_TOKEN( '>'      + DONT_REDUCE ),
                                     LEX_DELIMITER( '!'  ) AS_TOKEN( NOT      + DONT_REDUCE ),
                                     LEX_DELIMITER( '{'  ) AS_TOKEN( HB_CHK_BLOCK ),
                                     LEX_DELIMITER( '\\' ) AS_TOKEN( CBMARKER + DONT_REDUCE ), /* CodeBlock Marker '|' converted to '\' */
                                     LEX_DELIMITER( '|'  ) AS_TOKEN( BITOR    + DONT_REDUCE ),
                                     LEX_DELIMITER( '^' )  AS_TOKEN( POWER    + DONT_REDUCE ),
                                     LEX_DELIMITER( '%'  ) AS_TOKEN( '%'      + DONT_REDUCE ),
                                     LEX_DELIMITER( '*'  ) AS_TOKEN( '*'      + DONT_REDUCE ),
                                     LEX_DELIMITER( '/'  ) AS_TOKEN( '/'      + DONT_REDUCE ),
                                     LEX_DELIMITER( '+'  ) AS_TOKEN( '+'      + DONT_REDUCE ),
                                     LEX_DELIMITER( '-'  ) AS_TOKEN( '-'      + DONT_REDUCE ),
                                     LEX_DELIMITER( '$'  ) AS_TOKEN( '$'      + DONT_REDUCE )
                                   };

/* Custom Intermediate Token needed to be expanded. */
#define HB_LIT_ACT      LEX_CUSTOM_ACTION - 2

/* Stream Pairs. */
DEFINE_STREAM_AS_ONE_OF_THESE {
                                START_WITH("\"")     END_WITH("\"" )  STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("'")      END_WITH("'")    STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("[")      END_WITH("]" )   STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(TRUE ) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("E\"")    END_WITH("\"" )  STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT)
                              };

START_NEW_LINE_IF_ONE_OF_THESE( "\n;" );


#define HB_SELF         LEX_CUSTOM_ACTION - 4

SELF_CONTAINED_WORDS_ARE {
                           LEX_WORD( ".AND."  ) AS_TOKEN( AND        + DONT_REDUCE ),
                           LEX_WORD( ".F."    ) AS_TOKEN( FALSEVALUE + DONT_REDUCE ),
                           LEX_WORD( ".N."    ) AS_TOKEN( FALSEVALUE + DONT_REDUCE ),
                           LEX_WORD( ".NOT."  ) AS_TOKEN( NOT        + DONT_REDUCE ),
                           LEX_WORD( ".NULL." ) AS_TOKEN( NULLVALUE  + DONT_REDUCE ),
                           LEX_WORD( ".OR."   ) AS_TOKEN( OR         + DONT_REDUCE ),
                           LEX_WORD( ".T."    ) AS_TOKEN( TRUEVALUE  + DONT_REDUCE ),
                           LEX_WORD( ".Y."    ) AS_TOKEN( TRUEVALUE  + DONT_REDUCE ),
                           LEX_WORD( ":="     ) AS_TOKEN( INASSIGN                 ),
                           LEX_WORD( "::"     ) AS_TOKEN( HB_SELF                  ),
                           LEX_WORD( "=="     ) AS_TOKEN( EQ         + DONT_REDUCE ),
                           LEX_WORD( "=>"     ) AS_TOKEN( HASHOP     + DONT_REDUCE ),
                           LEX_WORD( "<<"     ) AS_TOKEN( BITSHIFTL  + DONT_REDUCE ),
                           LEX_WORD( "<="     ) AS_TOKEN( LE         + DONT_REDUCE ),
                           LEX_WORD( "<>"     ) AS_TOKEN( NE2        + DONT_REDUCE ),
                           LEX_WORD( ">="     ) AS_TOKEN( GE         + DONT_REDUCE ),
                           LEX_WORD( ">>"     ) AS_TOKEN( BITSHIFTR  + DONT_REDUCE ),
                           LEX_WORD( "!="     ) AS_TOKEN( NE2        + DONT_REDUCE ),
                           LEX_WORD( "++"     ) AS_TOKEN( INC                      ),
                           LEX_WORD( "+="     ) AS_TOKEN( PLUSEQ                   ),
                           LEX_WORD( "--"     ) AS_TOKEN( DEC                      ),
                           LEX_WORD( "-="     ) AS_TOKEN( MINUSEQ                  ),
                           LEX_WORD( "->"     ) AS_TOKEN( ALIASOP                  ),
                           LEX_WORD( "*="     ) AS_TOKEN( MULTEQ                   ),
                           LEX_WORD( "**"     ) AS_TOKEN( POWER      + DONT_REDUCE ),
                           LEX_WORD( "/="     ) AS_TOKEN( DIVEQ                    ),
                           LEX_WORD( "^="     ) AS_TOKEN( EXPEQ                    ),
                           LEX_WORD( "^^"     ) AS_TOKEN( BITXOR     + DONT_REDUCE ),
                           LEX_WORD( "%="     ) AS_TOKEN( MODEQ                    )
                         };

/* Intermediate KeyWords when ambigious. */
#define DO_WHILE         701
#define DO_WHILE_WITH    702

/* KEYWORDS are grouped based on the next token they require. */
#define WANTS_VAR        703 /* Wants Variable (including Macros): DO, FOR, PRIVATE, PUBLIC */
#define WANTS_ID         704 /* Wants Identifier: ANNOUNCE, ENUM, EXTERN, FIELD, FUNCTION, LOCAL, GLOBAL, EXTERNGLOBAL, MEMVAR, NAMESPACE PARAMETERS, PROCEDURE, STATIC */
#define WANTS_EOL        705 /* Wants EOL: ELSE, END, ENDSWITCH, ENDCASE, ENDDO, ENDIF, EXIT, LOOP, NEXT, OTHERWISE, RECOVER TRY*/
#define WANTS_EXP        706 /* Wants Expression: BREAK, CASE, ELSEIF, IF, IN, RETURN, WHILE, WITHOBJ SWITCH WITH_NAMESPACE */
#define REJECT_OP        707

//#define HB_TEXT          708

#define HB_WANTS_VAR     LEX_CUSTOM_ACTION - 512
#define HB_WANTS_ID      LEX_CUSTOM_ACTION - 1024
#define HB_WANTS_EOL     LEX_CUSTOM_ACTION - 1536
#define HB_WANTS_EXP     LEX_CUSTOM_ACTION - 2048

/* WORDS can NOT use HB_WANTS_EXP, instead must use HB_AFTER_EXP. */
#define HB_AFTER_EXP     LEX_CUSTOM_ACTION - 2560 /* LIKE, MATCH, STEP, TO */

/* When 2 identifiers are correct syntax like in class declaration, we have to temporarily store the 2nd identifier. */
#define HB_ID_ON_HOLD    LEX_CUSTOM_ACTION -  5

#define HB_MACRO_ERR     LEX_CUSTOM_ACTION -  6

#define HB_CRITICAL_FUNC        LEX_CUSTOM_ACTION -  7
#define HB_CRITICAL_PROC        LEX_CUSTOM_ACTION -  8
#define HB_CRITICAL_STATIC_FUNC LEX_CUSTOM_ACTION -  9
#define HB_CRITICAL_STATIC_PROC LEX_CUSTOM_ACTION - 10
#define HB_EXIT_FUNC            LEX_CUSTOM_ACTION - 11
#define HB_EXIT_PROC            LEX_CUSTOM_ACTION - 12
#define HB_INIT_FUNC            LEX_CUSTOM_ACTION - 13
#define HB_INIT_PROC            LEX_CUSTOM_ACTION - 14
#define HB_STATIC_FUNC          LEX_CUSTOM_ACTION - 15
#define HB_STATIC_PROC          LEX_CUSTOM_ACTION - 16

#define HB_DO_CASE_ID    LEX_CUSTOM_ACTION - 17

#define HB_DO_WHILE_ID   LEX_CUSTOM_ACTION - 18
#define HB_DO_WHILE_WITH LEX_CUSTOM_ACTION - 19

#define _WITH_ID_CR      LEX_CUSTOM_ACTION - 20
#define _WITH_ID_SEMI    LEX_CUSTOM_ACTION - 21

#define HB_IN            LEX_CUSTOM_ACTION - 22
#define HB_WITH          LEX_CUSTOM_ACTION - 23

/* When reservered words are used as Identifier. */
#define HB_IDENTIFIER    LEX_CUSTOM_ACTION - 24

/* #define HB_INLINE        LEX_CUSTOM_ACTION - 25 */

/*
#define HB_TEXT_BLOCK    LEX_CUSTOM_ACTION - 26
#define HB_TEXT_LINE     LEX_CUSTOM_ACTION - 27
#define HB_NEXT_LINE     LEX_CUSTOM_ACTION - 28

#define HB_TEXT_ID       LEX_CUSTOM_ACTION - 29
*/

#define HB_QSELF         LEX_CUSTOM_ACTION - 30

#define HB_FIELD_ALIAS   LEX_CUSTOM_ACTION - 31

#define HB_IIF_OPEN      LEX_CUSTOM_ACTION - 32

#define HB_H12AM         LEX_CUSTOM_ACTION - 33
#define HB_H12PM         LEX_CUSTOM_ACTION - 34

#define HB_UTIL_FUNC        LEX_CUSTOM_ACTION - 35
#define HB_UTIL_PROC        LEX_CUSTOM_ACTION - 36
#define HB_UTIL_STATIC_FUNC LEX_CUSTOM_ACTION - 37
#define HB_UTIL_STATIC_PROC LEX_CUSTOM_ACTION - 38

#define USE_KEYWORDS

/* Key Words. */
LANGUAGE_KEY_WORDS_ARE {
                         LEX_WORD( "ANNOUNCE"                        ) AS_TOKEN( HB_WANTS_ID  - ANNOUNCE         ),
                         LEX_WORD( "BEGIN{WS}SEQUENCE"               ) AS_TOKEN( BEGINSEQ         ),
                         LEX_WORD( "BREAK"                           ) AS_TOKEN( HB_WANTS_EXP - BREAK            ),
                         LEX_WORD( "CASE"                            ) AS_TOKEN( HB_WANTS_EXP - CASE             ),
                         LEX_WORD( "CATCH"                           ) AS_TOKEN( CATCH            ),
                         LEX_WORD( "CRITICAL{WS}FUNCTION"            ) AS_TOKEN( HB_CRITICAL_FUNC ),
                         LEX_WORD( "CRITICAL{WS}PROCEDURE"           ) AS_TOKEN( HB_CRITICAL_PROC ),
                         LEX_WORD( "CRITICAL{WS}STATIC{WS}FUNCTION"  ) AS_TOKEN( HB_CRITICAL_STATIC_FUNC ),
                         LEX_WORD( "CRITICAL{WS}STATIC{WS}PROCEDURE" ) AS_TOKEN( HB_CRITICAL_STATIC_PROC ),
                         LEX_WORD( "DECLARE"                         ) AS_TOKEN( DECLARE          ),
                         LEX_WORD( "DEFAULT"                         ) AS_TOKEN( HB_WANTS_EOL - DEFAULT          ),
                         LEX_WORD( "DEFINE{WS}NAMESPACE"             ) AS_TOKEN( HB_WANTS_ID  - DEFINE_NAMESPACE ),
                         LEX_WORD( "DEFINE{WS}NAMESPACE{WS}MEMBER"   ) AS_TOKEN( HB_WANTS_ID  - DEFINE_NAMESPACEMEMBER ),
                         LEX_WORD( "DIVERT{WS}TO"                    ) AS_TOKEN( HB_WANTS_EXP - DIVERT           ),
                         LEX_WORD( "DO"                              ) AS_TOKEN( HB_WANTS_VAR - DO               ),
                         LEX_WORD( "DO{WS}CASE"                      ) AS_TOKEN( DOCASE           ),
                         LEX_WORD( "DO{WS}WHILE"                     ) AS_TOKEN( DO_WHILE         ),
                         LEX_WORD( "DO{WS}WHILE{WS}WITH"             ) AS_TOKEN( DO_WHILE_WITH    ),
                         LEX_WORD( "DYNAMIC"                         ) AS_TOKEN( HB_WANTS_ID  - DYNAMIC          ),
                         LEX_WORD( "ELSE"                            ) AS_TOKEN( HB_WANTS_EOL - ELSE             ),
                         LEX_WORD( "ELSEIF"                          ) AS_TOKEN( HB_WANTS_EXP - ELSEIF           ),
                         LEX_WORD( "END"                             ) AS_TOKEN( HB_WANTS_EOL - END              ),
                         LEX_WORD( "ENDCASE"                         ) AS_TOKEN( HB_WANTS_EOL - ENDCASE          ),
                         LEX_WORD( "ENDDO"                           ) AS_TOKEN( HB_WANTS_EOL - ENDDO            ),
                         LEX_WORD( "ENDIF"                           ) AS_TOKEN( HB_WANTS_EOL - ENDIF            ),
                         LEX_WORD( "ENDSWITCH"                       ) AS_TOKEN( HB_WANTS_EOL - ENDSWITCH        ),
                         LEX_WORD( "ENUMERATION"                     ) AS_TOKEN( HB_WANTS_ID  - ENUM             ),
                         LEX_WORD( "EXIT"                            ) AS_TOKEN( HB_WANTS_EOL - EXIT             ),
                         LEX_WORD( "EXIT{WS}FUNCTION"                ) AS_TOKEN( HB_EXIT_FUNC     ),
                         LEX_WORD( "EXIT{WS}PROCEDURE"               ) AS_TOKEN( HB_EXIT_PROC     ),
                         LEX_WORD( "EXTERNAL"                        ) AS_TOKEN( HB_WANTS_ID  - EXTERN           ),
                         LEX_WORD( "EXTERNAL{WS}NAMESPACE"           ) AS_TOKEN( HB_WANTS_ID  - EXTERNAL_NAMESPACE ),
                         LEX_WORD( "EXTERNAL{WS}NAMESPACE{WS}MEMBER" ) AS_TOKEN( HB_WANTS_ID  - EXTERNAL_NAMESPACE_MEMBER ),
                         LEX_WORD( "FIELD"                           ) AS_TOKEN( HB_WANTS_ID  - FIELD            ),
                         LEX_WORD( "FINALLY"                         ) AS_TOKEN( HB_WANTS_EOL - FINALLY          ),
                         LEX_WORD( "FOR"                             ) AS_TOKEN( HB_WANTS_VAR - FOR              ),
                         LEX_WORD( "FOR{WS}EACH"                     ) AS_TOKEN( FOREACH                         ),
                         LEX_WORD( "FUNCTION"                        ) AS_TOKEN( HB_WANTS_ID  - FUNCTION         ),
                         LEX_WORD( "GLOBAL"                          ) AS_TOKEN( HB_WANTS_ID  - GLOBAL           ),
                         LEX_WORD( "GLOBAL{WS}EXTERNAL"              ) AS_TOKEN( EXTERNGLOBAL     ),
                         LEX_WORD( "IF"                              ) AS_TOKEN( HB_WANTS_EXP - IF               ),
                         LEX_WORD( "IMPLEMENTS{WS}NAMESPACE"         ) AS_TOKEN( HB_WANTS_ID  - IMPLEMENTS_NAMESPACE ),
                         LEX_WORD( "INIT{WS}FUNCTION"                ) AS_TOKEN( HB_INIT_FUNC     ),
                         LEX_WORD( "INIT{WS}PROCEDURE"               ) AS_TOKEN( HB_INIT_PROC     ),
                         LEX_WORD( "LOCAL"                           ) AS_TOKEN( HB_WANTS_ID  - LOCAL            ),
                         LEX_WORD( "LOOP"                            ) AS_TOKEN( HB_WANTS_EOL - LOOP             ),
                         LEX_WORD( "MEMVAR"                          ) AS_TOKEN( HB_WANTS_ID  - MEMVAR           ),
                         LEX_WORD( "NAMESPACE"                       ) AS_TOKEN( HB_WANTS_ID  - NAMESPACE        ),
                         LEX_WORD( "NEXT"                            ) AS_TOKEN( HB_WANTS_EOL - NEXT             ),
                         LEX_WORD( "OPTIONAL{WS}NAMESPACE"           ) AS_TOKEN( HB_WANTS_ID  - OPTIONAL_NAMESPACE ),
                         LEX_WORD( "OTHERWISE"                       ) AS_TOKEN( HB_WANTS_EOL - OTHERWISE        ),
                         LEX_WORD( "PARAMETERS"                      ) AS_TOKEN( HB_WANTS_ID  - PARAMETERS       ),
                         LEX_WORD( "PRIVATE"                         ) AS_TOKEN( HB_WANTS_VAR - PRIVATE          ),
                         LEX_WORD( "PROCEDURE"                       ) AS_TOKEN( HB_WANTS_ID  - PROCEDURE        ),
                         LEX_WORD( "PUBLIC"                          ) AS_TOKEN( HB_WANTS_VAR - PUBLIC           ),
                         LEX_WORD( "RECOVER"                         ) AS_TOKEN( HB_WANTS_EOL - RECOVER          ),
                         LEX_WORD( "RECOVER{WS}USING"                ) AS_TOKEN( RECOVERUSING     ),
                         LEX_WORD( "RETURN"                          ) AS_TOKEN( HB_WANTS_EXP - RETURN           ),
                         LEX_WORD( "RUNTIME{WS}NAMESPACE"            ) AS_TOKEN( HB_WANTS_ID  - RUNTIME_NAMESPACE ),
                         LEX_WORD( "STATIC"                          ) AS_TOKEN( HB_WANTS_ID  - STATIC           ),
                         LEX_WORD( "STATIC{WS}FUNCTION"              ) AS_TOKEN( HB_STATIC_FUNC   ),
                         LEX_WORD( "STATIC{WS}PROCEDURE"             ) AS_TOKEN( HB_STATIC_PROC   ),
                         LEX_WORD( "SWITCH"                          ) AS_TOKEN( HB_WANTS_EXP - SWITCH           ),
                      /* LEX_WORD( "TEXT"                            ) AS_TOKEN( HB_TEXT          ),                 */
                         LEX_WORD( "TRY"                             ) AS_TOKEN( HB_WANTS_EOL  - TRY             ),
                         LEX_WORD( "USING{WS}NAMESPACE{WS}PATH"      ) AS_TOKEN( HB_WANTS_ID  - USING_NAMESPACE  ),
                         LEX_WORD( "UTILITY{WS}FUNCTION"             ) AS_TOKEN( HB_UTIL_FUNC     ),
                         LEX_WORD( "UTILITY{WS}PROCEDURE"            ) AS_TOKEN( HB_UTIL_PROC     ),
                         LEX_WORD( "UTILITY{WS}STATIC{WS}FUNCTION"   ) AS_TOKEN( HB_UTIL_STATIC_FUNC ),
                         LEX_WORD( "UTILITY{WS}STATIC{WS}PROCEDURE"  ) AS_TOKEN( HB_UTIL_STATIC_PROC ),
                         LEX_WORD( "WHILE"                           ) AS_TOKEN( HB_WANTS_EXP - WHILE            ),
                         LEX_WORD( "WITH{WS}NAMESPACE{WS}PATH"       ) AS_TOKEN( WITH_NAMESPACE   ),
                         LEX_WORD( "WITH{WS}OBJECT"                  ) AS_TOKEN( WITHOBJ          ),
                         LEX_WORD( "_HB_CLASS"                       ) AS_TOKEN( DECLARE_CLASS    ),
                         LEX_WORD( "_HB_MEMBER"                      ) AS_TOKEN( DECLARE_MEMBER   ),
                         LEX_WORD( "_PROCREQ_"                       ) AS_TOKEN( PROCREQ          )
                       };

/* Intermediate Words when ambigious. */
#define QSELF     801
#define _LINE_    802

/* Words. */
LANGUAGE_WORDS_ARE {
                     LEX_WORD( "..."                              ) AS_TOKEN( EPSILON            + DONT_REDUCE ),

                     LEX_WORD( "AM"                               ) AS_TOKEN( HB_H12AM           ),
                     LEX_WORD( "AS{WS}ANYTYPE"                    ) AS_TOKEN( AS_VARIANT         + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY"                      ) AS_TOKEN( AS_ARRAY           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}ANYTYPE"     ) AS_TOKEN( AS_ARRAY           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}ARRAY"       ) AS_TOKEN( AS_ARRAY_ARRAY     + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}BLOCK"       ) AS_TOKEN( AS_BLOCK_ARRAY     + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}CHARACTER"   ) AS_TOKEN( AS_CHARACTER_ARRAY + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}CLASS"       ) AS_TOKEN( AS_CLASS_ARRAY     + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}CODEBLOCK"   ) AS_TOKEN( AS_BLOCK_ARRAY     + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}DATE"        ) AS_TOKEN( AS_DATE_ARRAY      + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}ENUMERATION" ) AS_TOKEN( AS_ENUM_ARRAY      + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}LOGICAL"     ) AS_TOKEN( AS_LOGICAL_ARRAY   + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}NUMERIC"     ) AS_TOKEN( AS_NUMERIC_ARRAY   + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}OBJECT"      ) AS_TOKEN( AS_OBJECT_ARRAY    + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}STRING"      ) AS_TOKEN( AS_CHARACTER_ARRAY + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}USUAL"       ) AS_TOKEN( AS_CHARACTER_ARRAY + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}BLOCK"                      ) AS_TOKEN( AS_BLOCK           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}CHARACTER"                  ) AS_TOKEN( AS_CHARACTER       + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}CLASS"                      ) AS_TOKEN( AS_CLASS           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}CODEBLOCK"                  ) AS_TOKEN( AS_BLOCK           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}DATE"                       ) AS_TOKEN( AS_DATE            + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ENUMERATION"                ) AS_TOKEN( AS_ENUM            + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}LOGICAL"                    ) AS_TOKEN( AS_LOGICAL         + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}NUMERIC"                    ) AS_TOKEN( AS_NUMERIC         + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}OBJECT"                     ) AS_TOKEN( AS_OBJECT          + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}STRING"                     ) AS_TOKEN( AS_CHARACTER       + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}USUAL"                      ) AS_TOKEN( AS_CHARACTER       + DONT_REDUCE ),

                  /* LEX_WORD( "FIELD"                            ) AS_TOKEN( FIELD              ), */

                     LEX_WORD( "FIELD?WS?->"                      ) AS_TOKEN( HB_FIELD_ALIAS     ),
                     LEX_WORD( "FLAGS"                            ) AS_TOKEN( HB_AFTER_EXP - FLAGS             ),
                     LEX_WORD( "HAS"                              ) AS_TOKEN( HB_AFTER_EXP - MATCH             ),

                  /* LEX_WORD( "HB_INLINE"                        ) AS_TOKEN( HB_INLINE          ), */

                  /* LEX_WORD( "IF"                               ) AS_TOKEN( IIF                ),
                     LEX_WORD( "IIF"                              ) AS_TOKEN( IIF                ), */

                     LEX_WORD( "IF?WS?("                          ) AS_TOKEN( HB_IIF_OPEN        ),

                     LEX_WORD( "IIF?WS?("                         ) AS_TOKEN( HB_IIF_OPEN        ),
                     LEX_WORD( "IMPLEMENTS{WS}NAMESPACE"          ) AS_TOKEN( HB_WANTS_ID - IMPLEMENTS_NAMESPACE ),
                     LEX_WORD( "IN"                               ) AS_TOKEN( HB_IN              ),
                     LEX_WORD( "LIKE"                             ) AS_TOKEN( HB_AFTER_EXP - LIKE              ),
                     LEX_WORD( "LINE"                             ) AS_TOKEN( _LINE_             ),
                     LEX_WORD( "NIL"                              ) AS_TOKEN( NIL                + DONT_REDUCE ),
                     LEX_WORD( "OF"                               ) AS_TOKEN( HB_AFTER_EXP - OF                ),
                     LEX_WORD( "OPTIONAL"                         ) AS_TOKEN( OPTIONAL           ),
                     LEX_WORD( "PM"                               ) AS_TOKEN( HB_H12PM           ),

                  /* LEX_WORD( "QSELF"                            ) AS_TOKEN( QSELF              ), */

                     LEX_WORD( "QSELF?WS?(?WS?)"                  ) AS_TOKEN( HB_QSELF           ),

                  /* LEX_WORD( "SELF"                             ) AS_TOKEN( SELF               ), */

                     LEX_WORD( "STEP"                             ) AS_TOKEN( HB_AFTER_EXP - STEP              ),
                     LEX_WORD( "TO"                               ) AS_TOKEN( HB_AFTER_EXP - TO                ),
                     LEX_WORD( "WITH"                             ) AS_TOKEN( HB_WITH            ),

                  /* LEX_WORD( "_FIELD"                           ) AS_TOKEN( FIELD              ), */

                     LEX_WORD( "_FIELD?WS?->"                     ) AS_TOKEN( HB_FIELD_ALIAS     ),
                     LEX_WORD( "_GET_?WS?("                       ) AS_TOKEN( GET                )
                   };

/* Intermediate Reductions when still ambigious or need further reductions. */
#define _ID_ARRAY         901
#define _ID_COMMA         902
#define _ID_CR            903
#define _ID_SEMI          904
#define _ID_ASSIGN        905
#define _WHL_ID_CR        906
#define _WHL_ID_SEMI      907

/* When 2 identifiers are correct syntax like in class declaration, we have to temporarily store the 2nd identifier. */
#define _ID_ON_HOLD       913

LANGUAGE_RULES_ARE {
                    /* Wants any Var. */
                    IF_SEQUENCE_IS( WANTS_VAR      , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_VAR      , MACROVAR    , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_VAR      , MACROTEXT   , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_VAR      , '&'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_VAR      , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( FOREACH        , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( FOREACH        , 0           , 0      , 0          ) REDUCE_TO( FOR, HB_IDENTIFIER ),

                    /* Wants Identifier. */
                    IF_SEQUENCE_IS( WANTS_ID       , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_ID       , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( CATCH          , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( CATCH          , '\n'        , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( CATCH          , ';'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( CATCH          , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    /* Wants EOL */
                    IF_SEQUENCE_IS( WANTS_EOL      , '\n'        , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_EOL      , ';'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_EOL      , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    /* Wants Expression ( DOESN'T WANT OPERATORS ) - At BOL, if followed by operator (other than logicals .t., .f., !) than Identifier else COMMAND. */
                    IF_SEQUENCE_IS( REJECT_OP      , INC         , '\n'   , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , INC         , ';'    , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , DEC         , '\n'   , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , DEC         , ';'    , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , INASSIGN    , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , ALIASOP     , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , PLUSEQ      , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , MINUSEQ     , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , MULTEQ      , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , DIVEQ       , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , EXPEQ       , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , MODEQ       , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , ')'         , 0      , 0          ) PASS_THROUGH(),
                 /* IF_SEQUENCE_IS( REJECT_OP      , '('         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , '['         , 0      , 0          ) PASS_THROUGH(), DONT uncomment!!!*/
                    IF_SEQUENCE_IS( REJECT_OP      , '='         , 0      , 0          ) PASS_THROUGH(),
                 /* IF_SEQUENCE_IS( REJECT_OP      , ':'         , 0      , 0          ) PASS_THROUGH(), */
                    IF_SEQUENCE_IS( REJECT_OP      , 0           , 0      , 0          ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , 0             ),

                    IF_SEQUENCE_IS( REJECT_OP      , OPTIONAL     , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),
                    IF_SEQUENCE_IS( REJECT_OP      , WANTS_ID     , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),
                    IF_SEQUENCE_IS( REJECT_OP      , WANTS_EXP    , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),
                    IF_SEQUENCE_IS( REJECT_OP      , WANTS_VAR    , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),


                    /* Complex */

                    IF_SEQUENCE_IS( DOCASE       , '\n'       , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( DOCASE       , ';'        , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( DOCASE       , 0          , 0      , 0          ) REDUCE_TO( HB_DO_CASE_ID     , 0             ),

                    IF_SEQUENCE_IS( DO_WHILE_WITH, '\n'       , 0      , 0          ) REDUCE_TO( WHILE + DONT_REDUCE, _WITH_ID_CR  ),
                    IF_SEQUENCE_IS( DO_WHILE_WITH, ';'        , 0      , 0          ) REDUCE_TO( WHILE + DONT_REDUCE, _WITH_ID_SEMI),
                    IF_SEQUENCE_IS( DO_WHILE_WITH, 0          , 0      , 0          ) REDUCE_TO( HB_DO_WHILE_WITH  , 0             ),

                    IF_SEQUENCE_IS( DO_WHILE     , '\n'       , 0      , 0          ) REDUCE_TO( HB_DO_WHILE_ID    , '\n' + DONT_REDUCE        ),
                    IF_SEQUENCE_IS( DO_WHILE     , ';'        , 0      , 0          ) REDUCE_TO( HB_DO_WHILE_ID    , ';' + DONT_REDUCE         ),
                    IF_SEQUENCE_IS( DO_WHILE     , 0          , 0      , 0          ) REDUCE_TO( WHILE + DONT_REDUCE, 0             ),


                    /* DECLARE as PRIVATE. */
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , '['    , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_ARRAY     ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , ','    , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_COMMA     ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , '\n'   , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_CR        ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , ';'    , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_SEMI      ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  ,INASSIGN, 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_ASSIGN    ),
                    IF_SEQUENCE_IS( DECLARE     , MACROVAR    , 0      , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , MACROVAR      ),
                    IF_SEQUENCE_IS( DECLARE     , MACROTEXT   , 0      , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , MACROTEXT     ),

                    /* Any other DECLARE IDENTIFIER, must be Strong Type DECLARE. */
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),

                    IF_SEQUENCE_IS( _ID_ON_HOLD , 0           , 0      , 0          ) REDUCE_TO( HB_ID_ON_HOLD      , 0                   ),

                    /* Any other DECLARE must be Identifier. */
                    IF_SEQUENCE_IS( DECLARE     , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER      , 0                   ),

                    /* Expnasions from DECLARE ...*/
                    IF_SEQUENCE_IS( _ID_ARRAY   , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , '[' + DONT_REDUCE      ),
                    IF_SEQUENCE_IS( _ID_COMMA   , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , ',' + DONT_REDUCE      ),
                    IF_SEQUENCE_IS( _ID_CR      , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , '\n' + DONT_REDUCE     ),
                    IF_SEQUENCE_IS( _ID_SEMI    , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , ';' + DONT_REDUCE      ),
                    IF_SEQUENCE_IS( _ID_ASSIGN  , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , INASSIGN + DONT_REDUCE ),


                    /* This FIELD is NOT at BOL wants only ->. */
                 /* IF_SEQUENCE_IS( FIELD       , ALIASOP     , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( FIELD       , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ), */


                 /* IF_SEQUENCE_IS( SELF        , ':'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( SELF        , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ), */

                    IF_SEQUENCE_IS( QSELF       , '('         , ')'    , 0          ) REDUCE_TO( SELF + DONT_REDUCE, 0             ),
                    IF_SEQUENCE_IS( QSELF       , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                 /* IF_SEQUENCE_IS( IIF         , '('         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( IIF         , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER      , 0            ), */

                    IF_SEQUENCE_IS( OPTIONAL    , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( OPTIONAL    , '@'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( OPTIONAL    , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( PROCREQ     , '('         , 0      , 0          ) REDUCE_TO( PROCREQ + DONT_REDUCE, 0          ),
                    IF_SEQUENCE_IS( PROCREQ     , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                 /* IF_SEQUENCE_IS( GET         , '('         , 0      , 0          ) REDUCE_TO( GET + DONT_REDUCE , 0             ),
                    IF_SEQUENCE_IS( GET         , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ), */

                    IF_SEQUENCE_IS( NE1         , _LINE_      , 0      , 0          ) REDUCE_TO( LINE + DONT_REDUCE, 0             ),
                    IF_SEQUENCE_IS( _LINE_      , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( '&'         , '\''        , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR      , 0             ),
                    IF_SEQUENCE_IS( '&'         , '"'         , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR      , 0             ),
                    IF_SEQUENCE_IS( '&'         , '['         , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR      , 0             ) // Might need a COMMA

                 /* IF_SEQUENCE_IS( HB_TEXT     , IDENTIFIER  , ','    , _ID_ON_HOLD) REDUCE_TO( HB_TEXT_BLOCK     , 0             ),
                    IF_SEQUENCE_IS( HB_TEXT     , 0           , 0      , 0          ) REDUCE_TO( HB_TEXT_ID        , 0             ) */
                   };

/* -------------------------------------------------  End of Language Definitions. ------------------------------------------------ */

/* SimpLex Macros. */

#undef LEX_CASE
   #define LEX_CASE(x) ( (  ( iRet = (x) ) > 96 && iRet < 123 ) ? iRet - 32 : iRet )

/* Commented 2001-08-29 - Not really needed!
#undef NEW_LINE_ACTION
   #define NEW_LINE_ACTION() \
                while( iTexts ) \
                { \
                   DEBUG_INFO( printf( "Releasing short term Text: %i = %s At: %i\n", iTexts, aTexts[iTexts - 1], aTexts[iTexts - 1] ) ); \
                   iTexts--; \
                   hb_xfree( aTexts[iTexts] ); \
                }
*/

#undef INTERCEPT_ACTION
   #define INTERCEPT_ACTION(x) x = hb_comp_SLX_InterceptAction( x )

#undef ELEMENT_TOKEN
  #define ELEMENT_TOKEN(x,y) hb_comp_SLX_ElementToken(x,y)

#undef YY_INPUT      /* to implement our own YY_INPUT function to manage PRGs without \n at the end */
   int yy_lex_input( char ** );
   #define YY_INPUT( buf, result, max_size ) result = yy_lex_input( &buf );

#undef CUSTOM_ACTION
   #define CUSTOM_ACTION(x) hb_comp_SLX_CustomAction( x )

#undef STREAM_EXCEPTION
   #define STREAM_EXCEPTION( sPair, cChar ) \
              hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_STRING_TERMINATOR, sPair, NULL ); \
              aiHold[ iHold++ ] = '\n'; \
              yylval.string = hb_compIdentifierNew( sPair, TRUE ); \
              aiHold[ iHold++ ] = LITERAL + DONT_REDUCE ;

#undef STREAM_APPEND
   #define STREAM_APPEND(x) \
      \
      if( sStart[0] == 'E' ) \
      { \
         if( x == '\\' ) \
         { \
            char cCode; \
            switch( *szBuffer ) \
            { \
               case '\\' : \
               case '"'  : \
               case '\'' : \
                  sPair [ iPairLen++ ] = *szBuffer++; \
                  iSize--; \
                  break; \
               \
               case 'n' : \
                  sPair [ iPairLen++ ] = '\n'; \
                  szBuffer++; \
                  iSize--; \
                  break; \
               \
               case 't' : \
                  sPair [ iPairLen++ ] = '\t'; \
                  szBuffer++; \
                  iSize--; \
                  break; \
               \
               case 'b' : \
                  sPair [ iPairLen++ ] = '\b'; \
                  szBuffer++; \
                  iSize--; \
                  break; \
               \
               case 'r' : \
                  sPair [ iPairLen++ ] = '\r'; \
                  szBuffer++; \
                  iSize--; \
                  break; \
               \
               case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : \
                  cCode = *szBuffer++ - '0'; \
                  iSize--; \
                  if ( *szBuffer >= '0' && *szBuffer <= '7' ) \
                  { \
                     cCode = ( cCode << 3 ) | ( *szBuffer++ - '0' ); \
                     iSize--; \
                     if ( *szBuffer >= '0' && *szBuffer <= '7' ) \
                     { \
                        cCode = ( cCode << 3 ) | ( *szBuffer++ - '0' ); \
                        iSize--; \
                     } \
                  } \
                  sPair[ iPairLen++ ] = cCode; \
                  break; \
               \
               case 'x' : \
                  if ( szBuffer[ 1 ] >= '0' && szBuffer[ 1 ] <= '9' ) \
                     cCode = *++szBuffer - '0'; \
                  else if ( szBuffer[ 1 ] >= 'A' && szBuffer[ 1 ] <= 'F' ) \
                     cCode = *++szBuffer - 'A'; \
                  else if ( szBuffer[ 1 ] >= 'a' && szBuffer[ 1 ] <= 'f' ) \
                     cCode = *++szBuffer - 'a'; \
                  else break; \
                  iSize -= 2; \
                  if ( szBuffer[ 1 ] >= '0' && szBuffer[ 1 ] <= '9' ) \
                     cCode = ( cCode << 4 ) | ( *++szBuffer - '0' ); \
                  else if ( szBuffer[ 1 ] >= 'A' && szBuffer[ 1 ] <= 'F' ) \
                     cCode = ( cCode << 4 ) | ( *++szBuffer - 'A' ); \
                  else if ( szBuffer[ 1 ] >= 'a' && szBuffer[ 1 ] <= 'f' ) \
                     cCode = ( cCode << 4 ) | ( *++szBuffer - 'a' ); \
                  else break; \
                  iSize--; \
                  szBuffer++; \
                  sPair[ iPairLen++ ] = cCode; \
                  break; \
               \
               default :\
                  sPair[ iPairLen++ ] = x; \
            } \
         } \
         else \
         { \
            sPair[ iPairLen++ ] = x; \
         } \
      } \
      else \
      { \
         char *sClose; \
         \
         sClose = strchr( szBuffer, sTerm[0] ); \
         \
         if( sClose ) \
         { \
            int iLen; \
            \
            szBuffer--; iSize++; \
            \
            iLen = ( int ) ( sClose - szBuffer ); \
            \
            if( iLen > iPairAllocated )\
            { \
               sPair = (char *) realloc( sPair, iLen + 1 ); \
               iPairAllocated = iLen + 1; \
            } \
            \
            hb_strncpy( sPair, szBuffer, iLen ); \
            sPair[ iLen ] = '\0'; \
            s_szBuffer = sClose + 1; \
            iSize -= (unsigned int) ( s_szBuffer - szBuffer ); \
            yylval.valChar.string = hb_compIdentifierNew( sPair, TRUE ); \
            yylval.valChar.length = iLen; \
            yylval.valChar.dealloc = FALSE; \
            \
            /*printf( "Lit: <%s>, Rest: <%s>\n", sPair, s_szBuffer );*/ \
            iPairToken = 0; \
            return LITERAL + DONT_REDUCE ; \
         } \
         else \
         { \
            szBuffer--; \
            szBuffer[strlen(szBuffer)-1] = '\0'; \
            hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_STRING_TERMINATOR, szBuffer, NULL ); \
            yylval.valChar.string = hb_compIdentifierNew( szBuffer, TRUE ); \
            yylval.valChar.length = (int) strlen( szBuffer ); \
            yylval.valChar.dealloc = FALSE; \
            iSize = 0; \
            iPairToken = 0; \
            return LITERAL + DONT_REDUCE; \
         } \
      }

#undef IF_BELONG_LEFT
   #define IF_BELONG_LEFT(chr) if( iLastToken == IDENTIFIER || iLastToken == SELF || iLastToken == ']' || iLastToken == MACROVAR || iLastToken == MACROTEXT || \
                                   iLastToken == ')' || iLastToken == '}' || iLastToken == LITERAL || iLastToken == WANTS_EOL || iLastToken == WANTS_ID || \
                                   iLastToken == WANTS_VAR || iLastToken == DECLARE || iLastToken == FIELD || /*iLastToken == SELF ||*/ iLastToken == QSELF || \
                                   iLastToken == IIF || iLastToken == PROCREQ || iLastToken == OPTIONAL /* || iLastToken == HB_TEXT */ )

/* Support Functions. */
static int hb_comp_SLX_InterceptAction( int iRet )
{
   if( iRet < 256 )
   {
      yytext[0] = (char) iRet;
      yytext[1] = '\0';
      yyleng = 1;
   }
   else if( iRet < 512 )
   {
      if( iRet == IDENTIFIER )
      {
         if( iIdentifier > 0 )
         {
            iIdentifier--;
         }
      }
      else if( yylval.string == NULL )
      {
         //yytext = sToken;
         yyleng = (int) strlen( yytext );
      }
   }
   else
   {
      //yytext = sToken;
      yyleng = (int) strlen( yytext );

      if( iRet == WANTS_EXP )
         { iRet = iWantsEXP; }
      else if( iRet == WANTS_EOL )
         { iRet = iWantsEOL; }
      else if( iRet == WANTS_ID )
         { iRet = iWantsID; }
      else if( iRet == WANTS_VAR )
         { iRet = iWantsVAR; }
      else if( iRet == REJECT_OP )
         { yylval.string = hb_compIdentifierNew( (char*) yytext, TRUE ); iRet = IDENTIFIER; }
      else
         { printf( "Error SLX0002 Missing handler for '%i' line: %i\n", iRet, hb_comp_iLine - 1 ); hb_comp_iErrorCount++; }
   }

   #ifdef SHOW_LEX_TOKENS
     if( iRet == IDENTIFIER )       { printf( "   IDENTIFIER = \"%s\"\n", yylval.string  ); }
     else if( iRet == LITERAL )     { printf( "   LITERAL = \"%s\" (%d)\n", yylval.valChar.string, yylval.valChar.length  ); }
     else if( iRet == MACROVAR )    { printf( "   MACROVAR = \"%s\"\n", yylval.string  ); }
     else if( iRet == MACROTEXT )   { printf( "   MACROTEXT = \"%s\"\n", yylval.string  ); }
     else if( iRet == NUM_INTEGER ) { printf( "   INTEGER = %i\n", yylval.valInteger.iNumber  ); }
     else if( iRet == NUM_LONG )    { printf( "   INTEGER = %li\n", yylval.valLong.lNumber  ); }
     else if( iRet == NUM_DOUBLE )  { printf( "   DOUBLE = %f\n", yylval.valDouble.dNumber  ); }
     else if( iRet < 256 )
     {
        if( iRet == '\n' || iRet == ';' ) { printf( "***END LINE %i\n", hb_comp_iLine - 1  ); }
        else if( iRet == -1 )             { printf( "!!!<EOF>\n" ); }
        else                              { printf( "   DELIMITER = \"%c\"\n", iRet  ); }
     }
     else                           { printf( "   TOKEN = %i\n", iRet  ); }

     fflush( stdout );
   #endif

   return iRet;
}

static int hb_comp_SLX_ElementToken( char* szToken, unsigned int iTokenLen )
{
   extern char *yytext;
   extern int yyleng;

   char* tmpPtr;
   int   iElement;

   #if 0
   /*
      Feb-26-2005 Resolved without the hack by adding ?WS? support to SimpLex.

      Hack to work around these tokens which may be folowed by a RESERVED WORD, and thus revert to IDENTIFIER.
      Example:

         FOR i := Field TO 9

      At this point here, sToken and yytext point to 'To', we must revert yytext top the correct IDENTIFIER value.
      The next token will be a RESERVED WORD which will not require its literal value.

      The only TOKENS that may exhibit this issue are: FIELD, QSELF, IIF and GET - note they are the only ones to
      not have a rule for a trailing IDENTIFIER.

      Not very nice, but it works - hb_compIdentifierNew() utilizes unique values with sharing logic.
    */
   if( iMatched == 1 && ( aiRules[iRule][0] == FIELD || aiRules[iRule][0] == QSELF || aiRules[iRule][0] == IIF || aiRules[iRule][0] == GET ) )
   {
      SimpLex_CheckWords();

      if( iRet  )
      {
         switch( aiRules[iRule][0] )
         {
            case FIELD:
              yytext = hb_compIdentifierNew( "FIELD", TRUE );
              break;

            case QSELF:
              yytext = hb_compIdentifierNew( "QSELF", TRUE );
              break;

            case IIF:
              yytext = hb_compIdentifierNew( "IIF", TRUE );
              break;

            case GET:
              yytext = hb_compIdentifierNew( "_GET_", TRUE );
              break;
         }

         return iRet;
      }
   }
   #endif

   yytext = szToken;
   yyleng = (int) iTokenLen;

   if( ( *yytext >= 'A' && *yytext <= 'Z' ) || *yytext == '&' || *yytext == '_' )
   {
      /* Macro. */
      if( ( tmpPtr = strrchr( yytext, '&' ) ) != NULL ) /* Right Search. */
      {
         /* Is '&' the first char? - Since its was right search that would be the only '&'. */
         if( tmpPtr == yytext )
         {
            /* Maybe just the Macro Operator. */
            if( yyleng == 1 )
            {
               if( IS_NUM( iLastToken ) || iLastToken == LITERAL || iLastToken == IDENTIFIER ||  iLastToken == MACROVAR || iLastToken == MACROTEXT ||
                   iLastToken == ')' || iLastToken == ']' || iLastToken == '}' )
               {
                  iElement = BITAND + DONT_REDUCE;
               }
               else
               {
                  iElement = '&';
               }
            }
            /* No '.' so Simple Macro. */
            else if( ( tmpPtr = strchr( yytext, '.' ) ) == NULL ) /* Left Search. */
            {
               /* Remove the '&'. */
               yyleng--;

               yylval.string = hb_compIdentifierNew( yytext + 1, TRUE );
               iElement = MACROVAR;
            }
            else if( tmpPtr == yytext + yyleng - 1 )
            {
               /* The only '.' is last char, so Simple Macro. */

               /* Remove the '&' and the '.' */
               yyleng -= 2;
               yytext[yyleng + 1] = '\0';

               yylval.string = hb_compIdentifierNew( yytext + 1, TRUE );
               iElement = MACROVAR;
            }
            else
            {
               /*
               yytext = hb_compIdentifierNew( yytext, TRUE );
               */
               yylval.string = hb_strdup( yytext );
               iElement = MACROTEXT;
            }
         }
         else
         {
            /*
            yytext = hb_compIdentifierNew( yytext, TRUE );
            */
            yylval.string = hb_strdup( yytext );
            iElement = MACROTEXT;
         }
      }
      else
      {
         DEBUG_INFO( printf(  "Element \"%s\" is IDENTIFIER\n", yytext ) );

         if( yyleng > 1 && yytext[ yyleng - 1 ] == '.' )
         {
            yytext[ --yyleng ] = '\0';
            aiHold[ iHold++ ] = '.' + DONT_REDUCE;
         }

         hb_compCheckIllegalChar( yytext );

         if( yyleng > HB_SYMBOL_NAME_LEN )
         {
            yytext[ HB_SYMBOL_NAME_LEN ] = '\0';
            yyleng = HB_SYMBOL_NAME_LEN;
         }

         if( iIdentifier )
         {
            DEBUG_INFO( printf( "*** iDentifier = %i - Holding %s\n", iIdentifier, yytext ) );
            sIdOnHold = hb_compIdentifierNew( yytext, TRUE );
            iElement = _ID_ON_HOLD;
         }
         else
         {
            iIdentifier++;
            DEBUG_INFO( printf( "Primary Identifier %s Increased to: %i\n", yytext, iIdentifier ) );
            yylval.string = hb_compIdentifierNew( yytext, TRUE );
            iElement = IDENTIFIER;
         }
      }
   }
   else
   {
      /* ConverNumber */

      HB_LONG lNumber;
      double dNumber;
      int iDec, iWidth;
      BOOL bError = FALSE;

      //yylval.string = (char*) hb_xgrab( TOKEN_SIZE );
      //yylval.string[0] = 0;
      yylval.string = NULL;

      iElement = hb_comp_SLX_Str2Num( yytext, &lNumber, &dNumber, &iDec, &iWidth, &bError );

      if( bError )
      {
         hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_SYNTAX, yytext, NULL );
         return yytext[0];
      }
      else if ( iElement == NUM_DOUBLE )
      {
         yylval.valDouble.dNumber = dNumber;
         yylval.valDouble.bDec = ( UCHAR ) iDec;
         yylval.valDouble.bWidth = ( UCHAR ) iWidth;
         yylval.valDouble.szValue = yytext;
      }
      else if( HB_LIM_INT16( lNumber ) )
      {
         yylval.valInteger.iNumber = ( int ) lNumber;
         yylval.valInteger.szValue = yytext;
         iElement = NUM_INTEGER;
      }
      else
      {
         yylval.valLong.lNumber = lNumber;
         yylval.valLong.szValue = yytext;
      }
      iElement += DONT_REDUCE;
   }

   DEBUG_INFO( printf(  "Element \"%s\" is %i\n", szToken, iElement ) );

   return iElement;
}

static int hb_comp_SLX_Str2Num( char* szNum, HB_LONG * plVal, double * pdVal, int * piDec, int * piWidth, BOOL* pbError )
{
   BOOL fDbl;

   fDbl = hb_compStrToNumErr( szNum, yyleng, plVal, pdVal, piDec, piWidth, pbError );
   return fDbl ? NUM_DOUBLE : NUM_LONG;
}

static int hb_comp_SLX_CustomAction( int x )
{
   char *pTmp;

   DEBUG_INFO( printf( "Custom Action for %i after: %i\n", x, iLastToken ) );

   if( x < HB_AFTER_EXP )
   {
      bIgnoreWords = FALSE;

      if( IS_NUM( iLastToken ) || iLastToken == LITERAL || iLastToken == IDENTIFIER ||  iLastToken == MACROVAR || iLastToken == MACROTEXT ||
          iLastToken == ')' || iLastToken == ']' || iLastToken == '}' ||
          iLastToken == FIELD || iLastToken == QSELF || iLastToken == IIF || iLastToken == GET )
      {
         return ( (-x) + (HB_AFTER_EXP) ) + DONT_REDUCE;
      }
      else
      {
         yylval.string = hb_compIdentifierNew( sToken, TRUE );
         iIdentifier++;
         DEBUG_INFO( printf( "HB_AFTER_EXP, Primary Identifier %s Increased to: %i\n", sToken, iIdentifier ) );
         return IDENTIFIER;
      }
   }
   else if( x < HB_WANTS_EXP )
   {
      bIgnoreWords = FALSE;
      iWantsEXP = (-x) + (HB_WANTS_EXP) ;
      return REJECT_OP;
   }
   else if( x < HB_WANTS_EOL )
   {
      iWantsEOL = (-x) + (HB_WANTS_EOL) ;
      return WANTS_EOL;
   }
   else if( x < HB_WANTS_ID )
   {
      iWantsID = (-x) + (HB_WANTS_ID) ;
      return WANTS_ID;
   }
   else if( x < HB_WANTS_VAR )
   {
      iWantsVAR = (-x) + (HB_WANTS_VAR) ;
      return WANTS_VAR;
   }

   switch ( x )
   {
      case HB_IDENTIFIER :
         bIgnoreWords = FALSE;
         yylval.string = hb_compIdentifierNew( yytext, TRUE );
         iIdentifier++;
         DEBUG_INFO( printf( "Primary Identifier %s Increased to: %i\n", yytext, iIdentifier ) );
         return IDENTIFIER + DONT_REDUCE;

      case HB_SELF :
         aiHold[ iHold++ ] = ':' + DONT_REDUCE ;
         yylval.string = hb_compIdentifierNew( "SELF", TRUE );
         iIdentifier++;
         DEBUG_INFO( printf( "HB_SELF, Primary Identifier %s Increased to: %i\n", "SELF", iIdentifier ) );
         return IDENTIFIER;

      case HB_CHK_BLOCK :
         pTmp = (char *) s_szBuffer;

         /* Skip White Space. */
         while( isspace( (BYTE) *pTmp ) )
         {
            pTmp++;
         }

         if( *pTmp == '|' )
         {
            unsigned int iBrackets = 1;
            char cTmp;
            BOOL bMacro = FALSE;

            *pTmp = '\\';

            pTmp++;

            while( *pTmp  )
            {
               if( *pTmp == '|' )
               {
                  *pTmp = '\\';
                  pTmp++;
                  break;
               }

               pTmp++;
            }

            if( s_sLastBlock == NULL )
            {
               while( *pTmp )
               {
                  if( *pTmp == '}' )
                  {
                     iBrackets--;
                     if( iBrackets == 0 )
                     {
                        break;
                     }
                  }
                  else if( *pTmp == '{' )
                  {
                     iBrackets++;
                  }
                  else if( *pTmp == '&' )
                  {
                     bMacro = TRUE;
                  }

                  pTmp++;
               }

               if( bMacro )
               {
                  pTmp++;
                  cTmp = *pTmp;
                  *pTmp = '\0';

                  s_sLastBlock = hb_compIdentifierNew( s_szBuffer - 1, TRUE );

                  *pTmp = cTmp;
               }
            }
         }

         return '{' + DONT_REDUCE;

      case HB_LIT_ACT :
         yylval.valChar.string = (char *) hb_xgrab( iPairLen + 1 );
         HB_MEMCPY( yylval.valChar.string, sPair, iPairLen + 1);
         yylval.valChar.length = iPairLen;
         yylval.valChar.dealloc = TRUE;
         return LITERAL + DONT_REDUCE;

      case HB_INIT_PROC :
         aiHold[ iHold++ ] = PROCEDURE + DONT_REDUCE;
         return INIT + DONT_REDUCE;

      case HB_INIT_FUNC :
         aiHold[ iHold++ ] = FUNCTION + DONT_REDUCE;
         return INIT + DONT_REDUCE;

      case HB_EXIT_PROC :
         aiHold[ iHold++ ] = PROCEDURE + DONT_REDUCE;
         return EXIT + DONT_REDUCE;

      case HB_EXIT_FUNC :
         aiHold[ iHold++ ] = FUNCTION + DONT_REDUCE;
         return EXIT + DONT_REDUCE;

      case HB_STATIC_PROC :
         aiHold[ iHold++ ] = PROCEDURE + DONT_REDUCE;
         return STATIC + DONT_REDUCE;

      case HB_UTIL_PROC :
         aiHold[ iHold++ ] = PROCEDURE + DONT_REDUCE;
         return UTILITY + DONT_REDUCE;

      case HB_UTIL_STATIC_PROC :
         aiHold[ iHold++ ] = PROCEDURE + DONT_REDUCE;
         aiHold[ iHold++ ] = STATIC + DONT_REDUCE;
         return UTILITY + DONT_REDUCE;

      case HB_STATIC_FUNC :
         aiHold[ iHold++ ] = FUNCTION + DONT_REDUCE;
         return STATIC + DONT_REDUCE;

      case HB_UTIL_FUNC :
         aiHold[ iHold++ ] = FUNCTION + DONT_REDUCE;
         return UTILITY + DONT_REDUCE;

      case HB_UTIL_STATIC_FUNC :
         aiHold[ iHold++ ] = FUNCTION + DONT_REDUCE;
         aiHold[ iHold++ ] = STATIC + DONT_REDUCE;
         return UTILITY + DONT_REDUCE;

      case HB_CRITICAL_PROC :
         aiHold[ iHold++ ] = PROCEDURE + DONT_REDUCE;
         return CRITICAL + DONT_REDUCE;

      case HB_CRITICAL_FUNC :
         aiHold[ iHold++ ] = FUNCTION + DONT_REDUCE;
         return CRITICAL + DONT_REDUCE;

      case HB_CRITICAL_STATIC_PROC :
         aiHold[ iHold++ ] = PROCEDURE + DONT_REDUCE;
         return CRITICAL_STATIC + DONT_REDUCE;

      case HB_CRITICAL_STATIC_FUNC :
         aiHold[ iHold++ ] = FUNCTION + DONT_REDUCE;
         return CRITICAL_STATIC + DONT_REDUCE;

      case HB_IN :
         bIgnoreWords = FALSE;

         // pTmp is the Begining of Line - skip white space.
         pTmp = (char *) szLexBuffer;
         while( *pTmp == ' ' || *pTmp == '\t' )
         {
            pTmp++;
         }

         // FIEL[D] statmenet?
         if( toupper( pTmp[0] ) == 'F' && toupper( pTmp[1] ) == 'I' && toupper( pTmp[2] ) == 'E' && toupper( pTmp[3] ) == 'L' )
         {
            if( toupper( pTmp[4] ) == 'D' || pTmp[4] == ' ' || pTmp[4] == '\t' )
            {
               if( iLastToken == IDENTIFIER )
               {
                  return IN + DONT_REDUCE;
               }
               else
               {
                  yylval.string = hb_compIdentifierNew( "IN", TRUE );
                  iIdentifier++;
                  DEBUG_INFO( printf( "HB_IN, Primary Identifier %s Increased to: %i\n", "IN", iIdentifier ) );
                  return IDENTIFIER;
               }
            }
         } // FOR statement?
         else if( toupper( pTmp[0] ) == 'F' && toupper( pTmp[1] ) == 'O' && toupper( pTmp[2] ) == 'R' )
         {
            if( pTmp[3] != ' ' && pTmp[3] != '\t' )
            {
               goto NOT_FOREACH;
            }

            pTmp += 4;
            while( *pTmp == ' ' || *pTmp == '\t' )
            {
               pTmp++;
            }

            // FOR EACH statemenr?
            if( toupper( pTmp[0] ) == 'E' && toupper( pTmp[1] ) == 'A' && toupper( pTmp[2] ) == 'C' && toupper( pTmp[3] ) == 'H' )
            {
               if( pTmp[4] == ' ' || pTmp[4] == '\t' )
               {
                  return IN + DONT_REDUCE;
               }
            }
         }

         NOT_FOREACH :

           if( iLastToken == 0 || iLastToken == '\n' || iLastToken == ';' ||
               iLastToken == '(' || iLastToken == '[' || iLastToken == '{' || iLastToken == CBMARKER || iLastToken == ',' ||
               iLastToken == WANTS_ID ||
               iLastToken == WITH ||
               iLastToken == REJECT_OP ||
               iLastToken == GET ||
               IS_OP( iLastToken )
             )
           {
              yylval.string = hb_compIdentifierNew( "IN", TRUE );
              iIdentifier++;
              DEBUG_INFO( printf( "HB_IN, Primary Identifier %s Increased to: %i\n", "IN", iIdentifier ) );
              return IDENTIFIER;
           }
           else
           {
              iWantsEXP = '$';
              return REJECT_OP;
           }

      case HB_H12AM :
         if( IS_NUM( iLastToken ) )
         {
            return H12AM + DONT_REDUCE;
         }
         else
         {
            yylval.string = hb_compIdentifierNew( "AM", TRUE );
            iIdentifier++;
            DEBUG_INFO( printf( "HB_H12AM, Primary Identifier %s Increased to: %i\n", "AM", iIdentifier ) );
            return IDENTIFIER;
         }

      case HB_H12PM :
         if( IS_NUM( iLastToken ) )
         {
            return H12PM + DONT_REDUCE;
         }
         else
         {
            yylval.string = hb_compIdentifierNew( "PM", TRUE );
            iIdentifier++;
            DEBUG_INFO( printf( "HB_H12PM, Primary Identifier %s Increased to: %i\n", "PM", iIdentifier ) );
            return IDENTIFIER;
         }

      case HB_WITH :
         bIgnoreWords = FALSE;

         if( iLastToken == IDENTIFIER || iLastToken == MACROVAR || iLastToken == MACROTEXT || iLastToken == ')' )
         {
            return WITH + DONT_REDUCE;
         }
         else
         {
            yylval.string = hb_compIdentifierNew( "WITH", TRUE );
            iIdentifier++;
            DEBUG_INFO( printf( "HB_WITH, Primary Identifier %s Increased to: %i\n", "WITH", iIdentifier ) );
            return IDENTIFIER;
         }

      case _WITH_ID_CR :
         aiHold[ iHold++ ] = '\n' + DONT_REDUCE;
         yylval.string = hb_compIdentifierNew( "WITH", TRUE );
         iIdentifier++;
         DEBUG_INFO( printf( "_WITH_ID_CR, Primary Identifier %s Increased to: %i\n", "WITH", iIdentifier ) );
         return IDENTIFIER + DONT_REDUCE;

      case _WITH_ID_SEMI :
         aiHold[ iHold++ ] = ';' + DONT_REDUCE;
         yylval.string = hb_compIdentifierNew( "WITH", TRUE );
         iIdentifier++;
         DEBUG_INFO( printf( "_WITH_ID_SEMI, Primary Identifier %s Increased to: %i\n", "WITH", iIdentifier ) );
         return IDENTIFIER + DONT_REDUCE;

      case HB_DO_WHILE_ID :
         iIdentifier++;
         DEBUG_INFO( printf( "HB_DO_WHILE_ID, Primary Identifier %s Increased to: %i\n", "WHILE", iIdentifier ) );
         yylval.string = hb_compIdentifierNew( "WHILE", TRUE );
         aiHold[ iHold++ ] = IDENTIFIER + DONT_REDUCE;
         return DO + DONT_REDUCE;

      case HB_DO_WHILE_WITH :
         aiHold[ iHold++ ] = WITH + DONT_REDUCE;
         yylval.string = hb_compIdentifierNew( "WHILE", TRUE );
         iIdentifier++;
         DEBUG_INFO( printf( "HB_DO_WHILE_WITH, Primary Identifier %s Increased to: %i\n", "WHILE", iIdentifier ) );
         aiHold[ iHold++ ] = IDENTIFIER + DONT_REDUCE;
         return DO + DONT_REDUCE;

      case HB_DO_CASE_ID :
         yylval.string = hb_compIdentifierNew( "CASE", TRUE );
         iIdentifier++;
         DEBUG_INFO( printf( "HB_DO_CASE_ID, Primary Identifier %s Increased to: %i\n", "CASE", iIdentifier ) );
         aiHold[ iHold++ ] = IDENTIFIER + DONT_REDUCE;
         return DO + DONT_REDUCE;

      case HB_MACRO_ERR :
         hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_SYNTAX, "&", NULL );
         return  0;

      case HB_ID_ON_HOLD :
         yylval.string = sIdOnHold;
         iIdentifier++;
         DEBUG_INFO( printf( "RELEASED ID_ON_HOLD: %s - Increased to: %i\n", sIdOnHold, iIdentifier ) );
         return IDENTIFIER;

      case HB_QSELF :
         bIgnoreWords = FALSE;
         return SELF;

      case HB_FIELD_ALIAS :
         aiHold[ iHold++ ] = ALIASOP;
         return FIELD;

      case HB_IIF_OPEN :
         aiHold[ iHold++ ] = '(';
         return IIF;

      default:
         printf( "Error SLX0001 Missing custom handler for '%i' line: %i\n", x, hb_comp_iLine - 1 );
         hb_comp_iErrorCount++;
   }

   return x;
}

int yy_lex_input( char **buffer )
{
   ULONG ulLen;
   char * szLine;

   szLine = hb_pp_nextLine( hb_comp_PP, &ulLen );
   hb_comp_iLine++; //= hb_pp_line( hb_comp_PP ) + 1;

   if( szLine && ulLen )
   {
      *buffer = szLine;
   }
   else
   {
      *buffer = NULL;
   }

   //printf( "[%i]>%s<]\n", hb_comp_iLine, *buffer );

   return ulLen;
}

char * hb_comp_SLX_LastBlock( BOOL bReset )
{
   if( bReset )
   {
      s_sLastBlock = NULL;
   }
   else
   {
      char *pTmp = (char *) s_sLastBlock + 1;

      /* Skip White Space. */
      while( isspace( (BYTE) *pTmp ) )
      {
         pTmp++;
      }

      *pTmp = '|';

      pTmp++;

      while( *pTmp  )
      {
         if( *pTmp == '\\' )
         {
            *pTmp = '|';
            break;
         }

         pTmp++;
      }
   }

   return s_sLastBlock;
}

static void hb_compCheckIllegalChar( char * szName )
{
   int i, iLen = (int) strlen( szName );

   for ( i = 0; i < iLen ; i++ )
   {
      if( ( ! isalnum( szName[i] ) ) && szName[ i ] != '_' )
      {
         hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_ILLEGAL_CHARACTER, hb_szAscii[ (int)(unsigned char) szName[i] ], NULL );
      }
   }
}
